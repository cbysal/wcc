## 简述
此文档规定了前端 IR 传递给后端时应当遵循的规则

## 原则
文档仅规定前后端约定，对于前段如何实现，过程中添加何等 IR 不作任何限制

## 支持的 IR 类型
ADD, BEQ, BGE, BGT, BLE, BLT, BNE, CALL, DIV, EQ, F2I, GE, GOTO, GT, I2F, L_NOT, LABEL, LE, LT, MEMSET_ZERO, MOD, MOV, MUL, NE, NEG, SUB\
下面规定了 IR 的作用及应遵循的构造规范
1. ADD/DIV/MUL/SUB
- 格式（以 ADD 为例）：
> 1. ADD, ITEMP, ITEMP, ITEMP
> 2. ADD, ITEMP, ITEMP, INT
> 3. ADD, FTEMP, FTEMP, FTEMP
> 4. ADD, FTEMP, FTEMP, FLOAT
- 作用：加法（ADD）/除法（DIV）/取模（MOD）/乘法（MUL）/减法（SUB），包含整型和浮点型，拥有 3 个操作数，第一操作数为保存运算结果的临时变量，第二操作数为运算符号左边的临时变量，第三操作数为作为运算符号右边的临时变量或立即数
- 注意：
> 1. 第一操作数和第二操作数只能是临时变量
> 2. 三个操作数的操作数据类型应当保持一致（全部为整型或浮点型）
> 3. 如果前端发现第二操作数和第三操作数都能被转化为立即数，那么应当在前段直接算出结果，并转化为等价语句，如 MOV，然后继续考虑常量传递
2. BEQ/BGE/BGT/BLE/BLT/BNE
- 格式（以 BEQ 为例）：
> 1. BEQ, LABEL, ITEMP, ITEMP
> 2. BEQ, LABEL, ITEMP, INT
> 3. BEQ, LABEL, FTEMP, FTEMP
> 4. BEQ, LABEL, FTEMP, FLOAT
- 作用：如果第二操作数相等（BEQ）/大于等于（BGE）/大于（BGT）/小于等于（BLE）/小于（BLT）/不等于（BNE）第三操作数，那么跳转至下一条第一操作数指向的 LABEL，否则，继续下一条 IR。拥有 3 个操作数，第一操作数为分支成功的 LABEL 指针，第二操作数为被比较的一个数的临时变量，第三操作数为被比较的一个数的临时变量或立即数
- 注意：
> 1. 第二操作数只能是临时变量
> 2. 第二操作数和第三操作数的操作数据类型应当保持一致（全部为整型或浮点型）
> 3. 如果前端发现第二操作数和第三操作数都能被转化为立即数，那么应当将该条件跳转转化为相应的非条件跳转，如 GOTO，并删除可能出现的死代码
3. CALL
- 格式：CALL, SYMBOL, {(ITEMP/FTEMP/INT/FLOAT)*}
- 作用：调用函数，第一操作数为函数的符号，后面的操作数全部都是传入的参数
4. EQ/GE/GT/LE/LT/NE
- 格式（以 EQ 为例）：
> 1. EQ, ITEMP, ITEMP, ITEMP
> 2. EQ, ITEMP, ITEMP, INT
> 3. EQ, ITEMP, FTEMP, FTEMP
> 4. EQ, ITEMP, FTEMP, FLOAT
- 作用：如果第二操作数相等（EQ）/大于等于（GE）/大于（GT）/小于等于（LE）/小于（LT）/不等于（NE）第三操作数，那么将第一操作数置 1，否则置 0。第一操作数为保存比较运算结果的临时变量，第二操作数为被比较的一个数的临时变量，第三操作数为被比较的一个数的临时变量或立即数
- 注意：
> 1. 第一操作数必然是 ITEMP，第二操作数只能是临时变量
> 2. 第二操作数和第三操作数的操作数据类型应当保持一致（全部为整型或浮点型）
> 3. 如果前端发现第二操作数和第三操作数都能被转化为立即数，那么应当在前段直接算出结果，并转化为等价语句，如 MOV，然后继续考虑常量传递
> 4. 尽量不要出现此类 IR
5. F2I
- 格式：F2I, ITEMP, FTEMP
- 作用：将 FTEMP 类型的第二立即数转化为 ITEMP 类型的第一立即数，即 int 到 float 的强制类型转换
- 注意：
> 1. 第一操作数必然是 ITEMP，第二操作数必然是 FTEMP
> 2. 如果前端发现能构造出第二操作数是立即数的类似格式的 F2I IR，那么应当在前段直接算出结果，并转化为等价语句，如 MOV，然后继续考虑常量传递
6. GOTO
- 格式：GOTO, LABEL
- 作用：跳转到第一操作数指向的 LABEL，第一操作数为 LABEL 指针
7. I2F
- 格式：I2F, FTEMP, ITEMP
- 作用：将 ITEMP 类型的第二立即数转化为 FTEMP 类型的第一立即数，即 float 到 int 的强制类型转换
- 注意：
> 1. 第一操作数必然是 FTEMP，第二操作数必然是 ITEMP
> 2. 如果前端发现能构造出第二操作数是立即数的类似格式的 I2F IR，那么应当在前段直接算出结果，并转化为等价语句，如 MOV，然后继续考虑常量传递
8. L_NOT
- 格式：
> 1. L_NOT, ITEMP, ITEMP
> 2. L_NOT, ITEMP, FTEMP
- 作用：如果第二操作数保存的数据为 0 或 0.0f，那么就将第一操作数置 1，否则置 0
- 注意：
> 1. 第一操作数必然是 ITEMP
> 2. 如果前端发现能构造出第二操作数是立即数的类似格式的 L_NOT IR，那么应当在前段直接算出结果，并转化为等价语句，如 MOV，然后继续考虑常量传递
> 3. 以上注意事项 2 中，对于浮点数的判断应当使用 union 中的 fVal 与 0.0f 比较，而不是取 iVal 与 0 比较，因为 float 有 2 个“零”
9. LABEL
- 格式：LABEL
- 作用：LABEL 占位符
- 注意：
> 1. 前端应当尽量减少 LABEL 个数
> 2. 后端应当在开始时给所有 LABEL 标号，方法就是在它的 items 中添加 IRItem（INT）
10. MEMSET_ZERO
- 格式：MEMSET_ZERO, SYMBOL
- 作用：初始化 SYMBOL 数组的值全部为 0
- 注意：SYMBOL 必须是一个数组类型的 SYMBOL
11. MOD
- 格式：
> 1. MOD, ITEMP, ITEMP, ITEMP
> 2. MOD, ITEMP, ITEMP, INT
- 作用：取模，仅支持整型，拥有 3 个操作数，第一操作数为保存运算结果的临时变量，第二操作数为运算符号左边的临时变量，第三操作数为作为运算符号右边的临时变量或立即数
- 注意：
> 1. 第一操作数和第二操作数只能是临时变量
> 2. 如果前端发现第二操作数和第三操作数都能被转化为立即数，那么应当在前段直接算出结果，并转化为等价语句，如 MOV，然后继续考虑常量传递
12. MOV
- 格式：
> 1. MOV, ITEMP, ITEMP
> 2. MOV, ITEMP, INT
> 3. MOV, ITEMP, SYMBOL, {(ITEMP/INT)*}
> 4. MOV, ITEMP, RETURN
> 5. MOV, FTEMP, FTEMP
> 6. MOV, FTEMP, FLOAT
> 7. MOV, FTEMP, SYMBOL, {(ITEMP/INT)*}
> 8. MOV, FTEMP, RETURN
> 9. MOV, SYMBOL, ITEMP, {(ITEMP/INT)*}
> 10. MOV, SYMBOL, FTEMP, {(ITEMP/INT)*}
> 11. MOV, RETURN, ITEMP
> 12. MOV, RETURN, FTEMP
> 13. MOV, RETURN, INT
> 14. MOV, RETURN, FLOAT
- 作用：实现数据在临时变量、立即数、符号、返回值之间的转移。
- 注意：
> 1. MOV, ITEMP/FTEMP, RETURN 表示读取返回值，在函数调用结束后以获取返回值
> 2. MOV, RETURN, ITEMP/FTEMP 表示将第二操作数作为返回值，在函数将要结束时使用
> 3. MOV, ITEMP/FTEMP, SYMBOL, {(ITEMP/INT)*} 表示读取符号对应数据到临时变量，一般翻译为 LOAD 指令。此 IR 第一操作数为存储 LOAD 结果的临时变量，第二操作数为符号（可能为数组）。如果第二操作数是数组，后面可能出现若干个整型的临时变量或立即数。如果第二操作数后面临时变量和立即数个数等于 SYMBOL 对应的维度，那么得到对应数组元素，否则，得到的是内层数组的地址
> 4. MOV, SYMBOL, ITEMP/FTEMP, {(ITEMP/INT)*} 表示读取符号对应数据到临时变量，一般翻译为 STORE 指令。此 IR 第一操作数为符号（可能为数组），第二操作数为存储 STORE 来源值的临时变量。如果第一操作数是数组，后面可能出现若干个整型的临时变量或立即数。第二操作数后面临时变量和立即数的个数之和必须等于 SYMBOL 对应的维度
> 5. 地址存储至 ITEMP
13. NEG
- 格式：
> 1. NEG, ITEMP, ITEMP
> 2. NEG, FTEMP, FTEMP
- 作用：取第二操作数的相反数给第一操作数
- 注意：
> 1. 第一操作数和第二操作数的类型必须保持一致
> 2. 如果前端发现能构造出第二操作数是立即数的类似格式的 NEG IR，那么应当在前段直接算出结果，并转化为等价语句，如 MOV，然后继续考虑常量传递