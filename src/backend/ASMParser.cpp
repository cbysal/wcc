#include <algorithm>
#include <iostream>

#include "ASMParser.h"
#include "RegAllocator.h"

using namespace std;

static unordered_map<unsigned, unsigned> num2powerMap = {
    {0x00000002, 1},  {0x00000004, 2},  {0x00000008, 3},  {0x00000010, 4},
    {0x00000020, 5},  {0x00000040, 6},  {0x00000080, 7},  {0x00000100, 8},
    {0x00000200, 9},  {0x00000400, 10}, {0x00000800, 11}, {0x00001000, 12},
    {0x00002000, 13}, {0x00004000, 14}, {0x00008000, 15}, {0x00010000, 16},
    {0x00020000, 17}, {0x00040000, 18}, {0x00080000, 19}, {0x00100000, 20},
    {0x00200000, 21}, {0x00400000, 22}, {0x00800000, 23}, {0x01000000, 24},
    {0x02000000, 25}, {0x04000000, 26}, {0x08000000, 27}, {0x10000000, 28},
    {0x20000000, 29}, {0x40000000, 30}, {0x80000000, 31}};
static unordered_map<unsigned, pair<unsigned, unsigned>> num2power2Map = {
    {0x00000003, {0, 1}},   {0x00000005, {0, 2}},   {0x00000006, {1, 2}},
    {0x00000009, {0, 3}},   {0x0000000a, {1, 3}},   {0x0000000c, {2, 3}},
    {0x00000011, {0, 4}},   {0x00000012, {1, 4}},   {0x00000014, {2, 4}},
    {0x00000018, {3, 4}},   {0x00000021, {0, 5}},   {0x00000022, {1, 5}},
    {0x00000024, {2, 5}},   {0x00000028, {3, 5}},   {0x00000030, {4, 5}},
    {0x00000041, {0, 6}},   {0x00000042, {1, 6}},   {0x00000044, {2, 6}},
    {0x00000048, {3, 6}},   {0x00000050, {4, 6}},   {0x00000060, {5, 6}},
    {0x00000081, {0, 7}},   {0x00000082, {1, 7}},   {0x00000084, {2, 7}},
    {0x00000088, {3, 7}},   {0x00000090, {4, 7}},   {0x000000a0, {5, 7}},
    {0x000000c0, {6, 7}},   {0x00000101, {0, 8}},   {0x00000102, {1, 8}},
    {0x00000104, {2, 8}},   {0x00000108, {3, 8}},   {0x00000110, {4, 8}},
    {0x00000120, {5, 8}},   {0x00000140, {6, 8}},   {0x00000180, {7, 8}},
    {0x00000201, {0, 9}},   {0x00000202, {1, 9}},   {0x00000204, {2, 9}},
    {0x00000208, {3, 9}},   {0x00000210, {4, 9}},   {0x00000220, {5, 9}},
    {0x00000240, {6, 9}},   {0x00000280, {7, 9}},   {0x00000300, {8, 9}},
    {0x00000401, {0, 10}},  {0x00000402, {1, 10}},  {0x00000404, {2, 10}},
    {0x00000408, {3, 10}},  {0x00000410, {4, 10}},  {0x00000420, {5, 10}},
    {0x00000440, {6, 10}},  {0x00000480, {7, 10}},  {0x00000500, {8, 10}},
    {0x00000600, {9, 10}},  {0x00000801, {0, 11}},  {0x00000802, {1, 11}},
    {0x00000804, {2, 11}},  {0x00000808, {3, 11}},  {0x00000810, {4, 11}},
    {0x00000820, {5, 11}},  {0x00000840, {6, 11}},  {0x00000880, {7, 11}},
    {0x00000900, {8, 11}},  {0x00000a00, {9, 11}},  {0x00000c00, {10, 11}},
    {0x00001001, {0, 12}},  {0x00001002, {1, 12}},  {0x00001004, {2, 12}},
    {0x00001008, {3, 12}},  {0x00001010, {4, 12}},  {0x00001020, {5, 12}},
    {0x00001040, {6, 12}},  {0x00001080, {7, 12}},  {0x00001100, {8, 12}},
    {0x00001200, {9, 12}},  {0x00001400, {10, 12}}, {0x00001800, {11, 12}},
    {0x00002001, {0, 13}},  {0x00002002, {1, 13}},  {0x00002004, {2, 13}},
    {0x00002008, {3, 13}},  {0x00002010, {4, 13}},  {0x00002020, {5, 13}},
    {0x00002040, {6, 13}},  {0x00002080, {7, 13}},  {0x00002100, {8, 13}},
    {0x00002200, {9, 13}},  {0x00002400, {10, 13}}, {0x00002800, {11, 13}},
    {0x00003000, {12, 13}}, {0x00004001, {0, 14}},  {0x00004002, {1, 14}},
    {0x00004004, {2, 14}},  {0x00004008, {3, 14}},  {0x00004010, {4, 14}},
    {0x00004020, {5, 14}},  {0x00004040, {6, 14}},  {0x00004080, {7, 14}},
    {0x00004100, {8, 14}},  {0x00004200, {9, 14}},  {0x00004400, {10, 14}},
    {0x00004800, {11, 14}}, {0x00005000, {12, 14}}, {0x00006000, {13, 14}},
    {0x00008001, {0, 15}},  {0x00008002, {1, 15}},  {0x00008004, {2, 15}},
    {0x00008008, {3, 15}},  {0x00008010, {4, 15}},  {0x00008020, {5, 15}},
    {0x00008040, {6, 15}},  {0x00008080, {7, 15}},  {0x00008100, {8, 15}},
    {0x00008200, {9, 15}},  {0x00008400, {10, 15}}, {0x00008800, {11, 15}},
    {0x00009000, {12, 15}}, {0x0000a000, {13, 15}}, {0x0000c000, {14, 15}},
    {0x00010001, {0, 16}},  {0x00010002, {1, 16}},  {0x00010004, {2, 16}},
    {0x00010008, {3, 16}},  {0x00010010, {4, 16}},  {0x00010020, {5, 16}},
    {0x00010040, {6, 16}},  {0x00010080, {7, 16}},  {0x00010100, {8, 16}},
    {0x00010200, {9, 16}},  {0x00010400, {10, 16}}, {0x00010800, {11, 16}},
    {0x00011000, {12, 16}}, {0x00012000, {13, 16}}, {0x00014000, {14, 16}},
    {0x00018000, {15, 16}}, {0x00020001, {0, 17}},  {0x00020002, {1, 17}},
    {0x00020004, {2, 17}},  {0x00020008, {3, 17}},  {0x00020010, {4, 17}},
    {0x00020020, {5, 17}},  {0x00020040, {6, 17}},  {0x00020080, {7, 17}},
    {0x00020100, {8, 17}},  {0x00020200, {9, 17}},  {0x00020400, {10, 17}},
    {0x00020800, {11, 17}}, {0x00021000, {12, 17}}, {0x00022000, {13, 17}},
    {0x00024000, {14, 17}}, {0x00028000, {15, 17}}, {0x00030000, {16, 17}},
    {0x00040001, {0, 18}},  {0x00040002, {1, 18}},  {0x00040004, {2, 18}},
    {0x00040008, {3, 18}},  {0x00040010, {4, 18}},  {0x00040020, {5, 18}},
    {0x00040040, {6, 18}},  {0x00040080, {7, 18}},  {0x00040100, {8, 18}},
    {0x00040200, {9, 18}},  {0x00040400, {10, 18}}, {0x00040800, {11, 18}},
    {0x00041000, {12, 18}}, {0x00042000, {13, 18}}, {0x00044000, {14, 18}},
    {0x00048000, {15, 18}}, {0x00050000, {16, 18}}, {0x00060000, {17, 18}},
    {0x00080001, {0, 19}},  {0x00080002, {1, 19}},  {0x00080004, {2, 19}},
    {0x00080008, {3, 19}},  {0x00080010, {4, 19}},  {0x00080020, {5, 19}},
    {0x00080040, {6, 19}},  {0x00080080, {7, 19}},  {0x00080100, {8, 19}},
    {0x00080200, {9, 19}},  {0x00080400, {10, 19}}, {0x00080800, {11, 19}},
    {0x00081000, {12, 19}}, {0x00082000, {13, 19}}, {0x00084000, {14, 19}},
    {0x00088000, {15, 19}}, {0x00090000, {16, 19}}, {0x000a0000, {17, 19}},
    {0x000c0000, {18, 19}}, {0x00100001, {0, 20}},  {0x00100002, {1, 20}},
    {0x00100004, {2, 20}},  {0x00100008, {3, 20}},  {0x00100010, {4, 20}},
    {0x00100020, {5, 20}},  {0x00100040, {6, 20}},  {0x00100080, {7, 20}},
    {0x00100100, {8, 20}},  {0x00100200, {9, 20}},  {0x00100400, {10, 20}},
    {0x00100800, {11, 20}}, {0x00101000, {12, 20}}, {0x00102000, {13, 20}},
    {0x00104000, {14, 20}}, {0x00108000, {15, 20}}, {0x00110000, {16, 20}},
    {0x00120000, {17, 20}}, {0x00140000, {18, 20}}, {0x00180000, {19, 20}},
    {0x00200001, {0, 21}},  {0x00200002, {1, 21}},  {0x00200004, {2, 21}},
    {0x00200008, {3, 21}},  {0x00200010, {4, 21}},  {0x00200020, {5, 21}},
    {0x00200040, {6, 21}},  {0x00200080, {7, 21}},  {0x00200100, {8, 21}},
    {0x00200200, {9, 21}},  {0x00200400, {10, 21}}, {0x00200800, {11, 21}},
    {0x00201000, {12, 21}}, {0x00202000, {13, 21}}, {0x00204000, {14, 21}},
    {0x00208000, {15, 21}}, {0x00210000, {16, 21}}, {0x00220000, {17, 21}},
    {0x00240000, {18, 21}}, {0x00280000, {19, 21}}, {0x00300000, {20, 21}},
    {0x00400001, {0, 22}},  {0x00400002, {1, 22}},  {0x00400004, {2, 22}},
    {0x00400008, {3, 22}},  {0x00400010, {4, 22}},  {0x00400020, {5, 22}},
    {0x00400040, {6, 22}},  {0x00400080, {7, 22}},  {0x00400100, {8, 22}},
    {0x00400200, {9, 22}},  {0x00400400, {10, 22}}, {0x00400800, {11, 22}},
    {0x00401000, {12, 22}}, {0x00402000, {13, 22}}, {0x00404000, {14, 22}},
    {0x00408000, {15, 22}}, {0x00410000, {16, 22}}, {0x00420000, {17, 22}},
    {0x00440000, {18, 22}}, {0x00480000, {19, 22}}, {0x00500000, {20, 22}},
    {0x00600000, {21, 22}}, {0x00800001, {0, 23}},  {0x00800002, {1, 23}},
    {0x00800004, {2, 23}},  {0x00800008, {3, 23}},  {0x00800010, {4, 23}},
    {0x00800020, {5, 23}},  {0x00800040, {6, 23}},  {0x00800080, {7, 23}},
    {0x00800100, {8, 23}},  {0x00800200, {9, 23}},  {0x00800400, {10, 23}},
    {0x00800800, {11, 23}}, {0x00801000, {12, 23}}, {0x00802000, {13, 23}},
    {0x00804000, {14, 23}}, {0x00808000, {15, 23}}, {0x00810000, {16, 23}},
    {0x00820000, {17, 23}}, {0x00840000, {18, 23}}, {0x00880000, {19, 23}},
    {0x00900000, {20, 23}}, {0x00a00000, {21, 23}}, {0x00c00000, {22, 23}},
    {0x01000001, {0, 24}},  {0x01000002, {1, 24}},  {0x01000004, {2, 24}},
    {0x01000008, {3, 24}},  {0x01000010, {4, 24}},  {0x01000020, {5, 24}},
    {0x01000040, {6, 24}},  {0x01000080, {7, 24}},  {0x01000100, {8, 24}},
    {0x01000200, {9, 24}},  {0x01000400, {10, 24}}, {0x01000800, {11, 24}},
    {0x01001000, {12, 24}}, {0x01002000, {13, 24}}, {0x01004000, {14, 24}},
    {0x01008000, {15, 24}}, {0x01010000, {16, 24}}, {0x01020000, {17, 24}},
    {0x01040000, {18, 24}}, {0x01080000, {19, 24}}, {0x01100000, {20, 24}},
    {0x01200000, {21, 24}}, {0x01400000, {22, 24}}, {0x01800000, {23, 24}},
    {0x02000001, {0, 25}},  {0x02000002, {1, 25}},  {0x02000004, {2, 25}},
    {0x02000008, {3, 25}},  {0x02000010, {4, 25}},  {0x02000020, {5, 25}},
    {0x02000040, {6, 25}},  {0x02000080, {7, 25}},  {0x02000100, {8, 25}},
    {0x02000200, {9, 25}},  {0x02000400, {10, 25}}, {0x02000800, {11, 25}},
    {0x02001000, {12, 25}}, {0x02002000, {13, 25}}, {0x02004000, {14, 25}},
    {0x02008000, {15, 25}}, {0x02010000, {16, 25}}, {0x02020000, {17, 25}},
    {0x02040000, {18, 25}}, {0x02080000, {19, 25}}, {0x02100000, {20, 25}},
    {0x02200000, {21, 25}}, {0x02400000, {22, 25}}, {0x02800000, {23, 25}},
    {0x03000000, {24, 25}}, {0x04000001, {0, 26}},  {0x04000002, {1, 26}},
    {0x04000004, {2, 26}},  {0x04000008, {3, 26}},  {0x04000010, {4, 26}},
    {0x04000020, {5, 26}},  {0x04000040, {6, 26}},  {0x04000080, {7, 26}},
    {0x04000100, {8, 26}},  {0x04000200, {9, 26}},  {0x04000400, {10, 26}},
    {0x04000800, {11, 26}}, {0x04001000, {12, 26}}, {0x04002000, {13, 26}},
    {0x04004000, {14, 26}}, {0x04008000, {15, 26}}, {0x04010000, {16, 26}},
    {0x04020000, {17, 26}}, {0x04040000, {18, 26}}, {0x04080000, {19, 26}},
    {0x04100000, {20, 26}}, {0x04200000, {21, 26}}, {0x04400000, {22, 26}},
    {0x04800000, {23, 26}}, {0x05000000, {24, 26}}, {0x06000000, {25, 26}},
    {0x08000001, {0, 27}},  {0x08000002, {1, 27}},  {0x08000004, {2, 27}},
    {0x08000008, {3, 27}},  {0x08000010, {4, 27}},  {0x08000020, {5, 27}},
    {0x08000040, {6, 27}},  {0x08000080, {7, 27}},  {0x08000100, {8, 27}},
    {0x08000200, {9, 27}},  {0x08000400, {10, 27}}, {0x08000800, {11, 27}},
    {0x08001000, {12, 27}}, {0x08002000, {13, 27}}, {0x08004000, {14, 27}},
    {0x08008000, {15, 27}}, {0x08010000, {16, 27}}, {0x08020000, {17, 27}},
    {0x08040000, {18, 27}}, {0x08080000, {19, 27}}, {0x08100000, {20, 27}},
    {0x08200000, {21, 27}}, {0x08400000, {22, 27}}, {0x08800000, {23, 27}},
    {0x09000000, {24, 27}}, {0x0a000000, {25, 27}}, {0x0c000000, {26, 27}},
    {0x10000001, {0, 28}},  {0x10000002, {1, 28}},  {0x10000004, {2, 28}},
    {0x10000008, {3, 28}},  {0x10000010, {4, 28}},  {0x10000020, {5, 28}},
    {0x10000040, {6, 28}},  {0x10000080, {7, 28}},  {0x10000100, {8, 28}},
    {0x10000200, {9, 28}},  {0x10000400, {10, 28}}, {0x10000800, {11, 28}},
    {0x10001000, {12, 28}}, {0x10002000, {13, 28}}, {0x10004000, {14, 28}},
    {0x10008000, {15, 28}}, {0x10010000, {16, 28}}, {0x10020000, {17, 28}},
    {0x10040000, {18, 28}}, {0x10080000, {19, 28}}, {0x10100000, {20, 28}},
    {0x10200000, {21, 28}}, {0x10400000, {22, 28}}, {0x10800000, {23, 28}},
    {0x11000000, {24, 28}}, {0x12000000, {25, 28}}, {0x14000000, {26, 28}},
    {0x18000000, {27, 28}}, {0x20000001, {0, 29}},  {0x20000002, {1, 29}},
    {0x20000004, {2, 29}},  {0x20000008, {3, 29}},  {0x20000010, {4, 29}},
    {0x20000020, {5, 29}},  {0x20000040, {6, 29}},  {0x20000080, {7, 29}},
    {0x20000100, {8, 29}},  {0x20000200, {9, 29}},  {0x20000400, {10, 29}},
    {0x20000800, {11, 29}}, {0x20001000, {12, 29}}, {0x20002000, {13, 29}},
    {0x20004000, {14, 29}}, {0x20008000, {15, 29}}, {0x20010000, {16, 29}},
    {0x20020000, {17, 29}}, {0x20040000, {18, 29}}, {0x20080000, {19, 29}},
    {0x20100000, {20, 29}}, {0x20200000, {21, 29}}, {0x20400000, {22, 29}},
    {0x20800000, {23, 29}}, {0x21000000, {24, 29}}, {0x22000000, {25, 29}},
    {0x24000000, {26, 29}}, {0x28000000, {27, 29}}, {0x30000000, {28, 29}},
    {0x40000001, {0, 30}},  {0x40000002, {1, 30}},  {0x40000004, {2, 30}},
    {0x40000008, {3, 30}},  {0x40000010, {4, 30}},  {0x40000020, {5, 30}},
    {0x40000040, {6, 30}},  {0x40000080, {7, 30}},  {0x40000100, {8, 30}},
    {0x40000200, {9, 30}},  {0x40000400, {10, 30}}, {0x40000800, {11, 30}},
    {0x40001000, {12, 30}}, {0x40002000, {13, 30}}, {0x40004000, {14, 30}},
    {0x40008000, {15, 30}}, {0x40010000, {16, 30}}, {0x40020000, {17, 30}},
    {0x40040000, {18, 30}}, {0x40080000, {19, 30}}, {0x40100000, {20, 30}},
    {0x40200000, {21, 30}}, {0x40400000, {22, 30}}, {0x40800000, {23, 30}},
    {0x41000000, {24, 30}}, {0x42000000, {25, 30}}, {0x44000000, {26, 30}},
    {0x48000000, {27, 30}}, {0x50000000, {28, 30}}, {0x60000000, {29, 30}},
    {0x80000001, {0, 31}},  {0x80000002, {1, 31}},  {0x80000004, {2, 31}},
    {0x80000008, {3, 31}},  {0x80000010, {4, 31}},  {0x80000020, {5, 31}},
    {0x80000040, {6, 31}},  {0x80000080, {7, 31}},  {0x80000100, {8, 31}},
    {0x80000200, {9, 31}},  {0x80000400, {10, 31}}, {0x80000800, {11, 31}},
    {0x80001000, {12, 31}}, {0x80002000, {13, 31}}, {0x80004000, {14, 31}},
    {0x80008000, {15, 31}}, {0x80010000, {16, 31}}, {0x80020000, {17, 31}},
    {0x80040000, {18, 31}}, {0x80080000, {19, 31}}, {0x80100000, {20, 31}},
    {0x80200000, {21, 31}}, {0x80400000, {22, 31}}, {0x80800000, {23, 31}},
    {0x81000000, {24, 31}}, {0x82000000, {25, 31}}, {0x84000000, {26, 31}},
    {0x88000000, {27, 31}}, {0x90000000, {28, 31}}, {0xa0000000, {29, 31}},
    {0xc0000000, {30, 31}}};
static unordered_map<unsigned, pair<unsigned, unsigned>> num2rotateMap = {
    {0x00000007, {0, 2}},   {0x0000000e, {1, 3}},   {0x0000000f, {0, 3}},
    {0x0000001c, {2, 4}},   {0x0000001e, {1, 4}},   {0x0000001f, {0, 4}},
    {0x00000038, {3, 5}},   {0x0000003c, {2, 5}},   {0x0000003e, {1, 5}},
    {0x0000003f, {0, 5}},   {0x00000070, {4, 6}},   {0x00000078, {3, 6}},
    {0x0000007c, {2, 6}},   {0x0000007e, {1, 6}},   {0x0000007f, {0, 6}},
    {0x000000e0, {5, 7}},   {0x000000f0, {4, 7}},   {0x000000f8, {3, 7}},
    {0x000000fc, {2, 7}},   {0x000000fe, {1, 7}},   {0x000000ff, {0, 7}},
    {0x000001c0, {6, 8}},   {0x000001e0, {5, 8}},   {0x000001f0, {4, 8}},
    {0x000001f8, {3, 8}},   {0x000001fc, {2, 8}},   {0x000001fe, {1, 8}},
    {0x000001ff, {0, 8}},   {0x00000380, {7, 9}},   {0x000003c0, {6, 9}},
    {0x000003e0, {5, 9}},   {0x000003f0, {4, 9}},   {0x000003f8, {3, 9}},
    {0x000003fc, {2, 9}},   {0x000003fe, {1, 9}},   {0x000003ff, {0, 9}},
    {0x00000700, {8, 10}},  {0x00000780, {7, 10}},  {0x000007c0, {6, 10}},
    {0x000007e0, {5, 10}},  {0x000007f0, {4, 10}},  {0x000007f8, {3, 10}},
    {0x000007fc, {2, 10}},  {0x000007fe, {1, 10}},  {0x000007ff, {0, 10}},
    {0x00000e00, {9, 11}},  {0x00000f00, {8, 11}},  {0x00000f80, {7, 11}},
    {0x00000fc0, {6, 11}},  {0x00000fe0, {5, 11}},  {0x00000ff0, {4, 11}},
    {0x00000ff8, {3, 11}},  {0x00000ffc, {2, 11}},  {0x00000ffe, {1, 11}},
    {0x00000fff, {0, 11}},  {0x00001c00, {10, 12}}, {0x00001e00, {9, 12}},
    {0x00001f00, {8, 12}},  {0x00001f80, {7, 12}},  {0x00001fc0, {6, 12}},
    {0x00001fe0, {5, 12}},  {0x00001ff0, {4, 12}},  {0x00001ff8, {3, 12}},
    {0x00001ffc, {2, 12}},  {0x00001ffe, {1, 12}},  {0x00001fff, {0, 12}},
    {0x00003800, {11, 13}}, {0x00003c00, {10, 13}}, {0x00003e00, {9, 13}},
    {0x00003f00, {8, 13}},  {0x00003f80, {7, 13}},  {0x00003fc0, {6, 13}},
    {0x00003fe0, {5, 13}},  {0x00003ff0, {4, 13}},  {0x00003ff8, {3, 13}},
    {0x00003ffc, {2, 13}},  {0x00003ffe, {1, 13}},  {0x00003fff, {0, 13}},
    {0x00007000, {12, 14}}, {0x00007800, {11, 14}}, {0x00007c00, {10, 14}},
    {0x00007e00, {9, 14}},  {0x00007f00, {8, 14}},  {0x00007f80, {7, 14}},
    {0x00007fc0, {6, 14}},  {0x00007fe0, {5, 14}},  {0x00007ff0, {4, 14}},
    {0x00007ff8, {3, 14}},  {0x00007ffc, {2, 14}},  {0x00007ffe, {1, 14}},
    {0x00007fff, {0, 14}},  {0x0000e000, {13, 15}}, {0x0000f000, {12, 15}},
    {0x0000f800, {11, 15}}, {0x0000fc00, {10, 15}}, {0x0000fe00, {9, 15}},
    {0x0000ff00, {8, 15}},  {0x0000ff80, {7, 15}},  {0x0000ffc0, {6, 15}},
    {0x0000ffe0, {5, 15}},  {0x0000fff0, {4, 15}},  {0x0000fff8, {3, 15}},
    {0x0000fffc, {2, 15}},  {0x0000fffe, {1, 15}},  {0x0000ffff, {0, 15}},
    {0x0001c000, {14, 16}}, {0x0001e000, {13, 16}}, {0x0001f000, {12, 16}},
    {0x0001f800, {11, 16}}, {0x0001fc00, {10, 16}}, {0x0001fe00, {9, 16}},
    {0x0001ff00, {8, 16}},  {0x0001ff80, {7, 16}},  {0x0001ffc0, {6, 16}},
    {0x0001ffe0, {5, 16}},  {0x0001fff0, {4, 16}},  {0x0001fff8, {3, 16}},
    {0x0001fffc, {2, 16}},  {0x0001fffe, {1, 16}},  {0x0001ffff, {0, 16}},
    {0x00038000, {15, 17}}, {0x0003c000, {14, 17}}, {0x0003e000, {13, 17}},
    {0x0003f000, {12, 17}}, {0x0003f800, {11, 17}}, {0x0003fc00, {10, 17}},
    {0x0003fe00, {9, 17}},  {0x0003ff00, {8, 17}},  {0x0003ff80, {7, 17}},
    {0x0003ffc0, {6, 17}},  {0x0003ffe0, {5, 17}},  {0x0003fff0, {4, 17}},
    {0x0003fff8, {3, 17}},  {0x0003fffc, {2, 17}},  {0x0003fffe, {1, 17}},
    {0x0003ffff, {0, 17}},  {0x00070000, {16, 18}}, {0x00078000, {15, 18}},
    {0x0007c000, {14, 18}}, {0x0007e000, {13, 18}}, {0x0007f000, {12, 18}},
    {0x0007f800, {11, 18}}, {0x0007fc00, {10, 18}}, {0x0007fe00, {9, 18}},
    {0x0007ff00, {8, 18}},  {0x0007ff80, {7, 18}},  {0x0007ffc0, {6, 18}},
    {0x0007ffe0, {5, 18}},  {0x0007fff0, {4, 18}},  {0x0007fff8, {3, 18}},
    {0x0007fffc, {2, 18}},  {0x0007fffe, {1, 18}},  {0x0007ffff, {0, 18}},
    {0x000e0000, {17, 19}}, {0x000f0000, {16, 19}}, {0x000f8000, {15, 19}},
    {0x000fc000, {14, 19}}, {0x000fe000, {13, 19}}, {0x000ff000, {12, 19}},
    {0x000ff800, {11, 19}}, {0x000ffc00, {10, 19}}, {0x000ffe00, {9, 19}},
    {0x000fff00, {8, 19}},  {0x000fff80, {7, 19}},  {0x000fffc0, {6, 19}},
    {0x000fffe0, {5, 19}},  {0x000ffff0, {4, 19}},  {0x000ffff8, {3, 19}},
    {0x000ffffc, {2, 19}},  {0x000ffffe, {1, 19}},  {0x000fffff, {0, 19}},
    {0x001c0000, {18, 20}}, {0x001e0000, {17, 20}}, {0x001f0000, {16, 20}},
    {0x001f8000, {15, 20}}, {0x001fc000, {14, 20}}, {0x001fe000, {13, 20}},
    {0x001ff000, {12, 20}}, {0x001ff800, {11, 20}}, {0x001ffc00, {10, 20}},
    {0x001ffe00, {9, 20}},  {0x001fff00, {8, 20}},  {0x001fff80, {7, 20}},
    {0x001fffc0, {6, 20}},  {0x001fffe0, {5, 20}},  {0x001ffff0, {4, 20}},
    {0x001ffff8, {3, 20}},  {0x001ffffc, {2, 20}},  {0x001ffffe, {1, 20}},
    {0x001fffff, {0, 20}},  {0x00380000, {19, 21}}, {0x003c0000, {18, 21}},
    {0x003e0000, {17, 21}}, {0x003f0000, {16, 21}}, {0x003f8000, {15, 21}},
    {0x003fc000, {14, 21}}, {0x003fe000, {13, 21}}, {0x003ff000, {12, 21}},
    {0x003ff800, {11, 21}}, {0x003ffc00, {10, 21}}, {0x003ffe00, {9, 21}},
    {0x003fff00, {8, 21}},  {0x003fff80, {7, 21}},  {0x003fffc0, {6, 21}},
    {0x003fffe0, {5, 21}},  {0x003ffff0, {4, 21}},  {0x003ffff8, {3, 21}},
    {0x003ffffc, {2, 21}},  {0x003ffffe, {1, 21}},  {0x003fffff, {0, 21}},
    {0x00700000, {20, 22}}, {0x00780000, {19, 22}}, {0x007c0000, {18, 22}},
    {0x007e0000, {17, 22}}, {0x007f0000, {16, 22}}, {0x007f8000, {15, 22}},
    {0x007fc000, {14, 22}}, {0x007fe000, {13, 22}}, {0x007ff000, {12, 22}},
    {0x007ff800, {11, 22}}, {0x007ffc00, {10, 22}}, {0x007ffe00, {9, 22}},
    {0x007fff00, {8, 22}},  {0x007fff80, {7, 22}},  {0x007fffc0, {6, 22}},
    {0x007fffe0, {5, 22}},  {0x007ffff0, {4, 22}},  {0x007ffff8, {3, 22}},
    {0x007ffffc, {2, 22}},  {0x007ffffe, {1, 22}},  {0x007fffff, {0, 22}},
    {0x00e00000, {21, 23}}, {0x00f00000, {20, 23}}, {0x00f80000, {19, 23}},
    {0x00fc0000, {18, 23}}, {0x00fe0000, {17, 23}}, {0x00ff0000, {16, 23}},
    {0x00ff8000, {15, 23}}, {0x00ffc000, {14, 23}}, {0x00ffe000, {13, 23}},
    {0x00fff000, {12, 23}}, {0x00fff800, {11, 23}}, {0x00fffc00, {10, 23}},
    {0x00fffe00, {9, 23}},  {0x00ffff00, {8, 23}},  {0x00ffff80, {7, 23}},
    {0x00ffffc0, {6, 23}},  {0x00ffffe0, {5, 23}},  {0x00fffff0, {4, 23}},
    {0x00fffff8, {3, 23}},  {0x00fffffc, {2, 23}},  {0x00fffffe, {1, 23}},
    {0x00ffffff, {0, 23}},  {0x01c00000, {22, 24}}, {0x01e00000, {21, 24}},
    {0x01f00000, {20, 24}}, {0x01f80000, {19, 24}}, {0x01fc0000, {18, 24}},
    {0x01fe0000, {17, 24}}, {0x01ff0000, {16, 24}}, {0x01ff8000, {15, 24}},
    {0x01ffc000, {14, 24}}, {0x01ffe000, {13, 24}}, {0x01fff000, {12, 24}},
    {0x01fff800, {11, 24}}, {0x01fffc00, {10, 24}}, {0x01fffe00, {9, 24}},
    {0x01ffff00, {8, 24}},  {0x01ffff80, {7, 24}},  {0x01ffffc0, {6, 24}},
    {0x01ffffe0, {5, 24}},  {0x01fffff0, {4, 24}},  {0x01fffff8, {3, 24}},
    {0x01fffffc, {2, 24}},  {0x01fffffe, {1, 24}},  {0x01ffffff, {0, 24}},
    {0x03800000, {23, 25}}, {0x03c00000, {22, 25}}, {0x03e00000, {21, 25}},
    {0x03f00000, {20, 25}}, {0x03f80000, {19, 25}}, {0x03fc0000, {18, 25}},
    {0x03fe0000, {17, 25}}, {0x03ff0000, {16, 25}}, {0x03ff8000, {15, 25}},
    {0x03ffc000, {14, 25}}, {0x03ffe000, {13, 25}}, {0x03fff000, {12, 25}},
    {0x03fff800, {11, 25}}, {0x03fffc00, {10, 25}}, {0x03fffe00, {9, 25}},
    {0x03ffff00, {8, 25}},  {0x03ffff80, {7, 25}},  {0x03ffffc0, {6, 25}},
    {0x03ffffe0, {5, 25}},  {0x03fffff0, {4, 25}},  {0x03fffff8, {3, 25}},
    {0x03fffffc, {2, 25}},  {0x03fffffe, {1, 25}},  {0x03ffffff, {0, 25}},
    {0x07000000, {24, 26}}, {0x07800000, {23, 26}}, {0x07c00000, {22, 26}},
    {0x07e00000, {21, 26}}, {0x07f00000, {20, 26}}, {0x07f80000, {19, 26}},
    {0x07fc0000, {18, 26}}, {0x07fe0000, {17, 26}}, {0x07ff0000, {16, 26}},
    {0x07ff8000, {15, 26}}, {0x07ffc000, {14, 26}}, {0x07ffe000, {13, 26}},
    {0x07fff000, {12, 26}}, {0x07fff800, {11, 26}}, {0x07fffc00, {10, 26}},
    {0x07fffe00, {9, 26}},  {0x07ffff00, {8, 26}},  {0x07ffff80, {7, 26}},
    {0x07ffffc0, {6, 26}},  {0x07ffffe0, {5, 26}},  {0x07fffff0, {4, 26}},
    {0x07fffff8, {3, 26}},  {0x07fffffc, {2, 26}},  {0x07fffffe, {1, 26}},
    {0x07ffffff, {0, 26}},  {0x0e000000, {25, 27}}, {0x0f000000, {24, 27}},
    {0x0f800000, {23, 27}}, {0x0fc00000, {22, 27}}, {0x0fe00000, {21, 27}},
    {0x0ff00000, {20, 27}}, {0x0ff80000, {19, 27}}, {0x0ffc0000, {18, 27}},
    {0x0ffe0000, {17, 27}}, {0x0fff0000, {16, 27}}, {0x0fff8000, {15, 27}},
    {0x0fffc000, {14, 27}}, {0x0fffe000, {13, 27}}, {0x0ffff000, {12, 27}},
    {0x0ffff800, {11, 27}}, {0x0ffffc00, {10, 27}}, {0x0ffffe00, {9, 27}},
    {0x0fffff00, {8, 27}},  {0x0fffff80, {7, 27}},  {0x0fffffc0, {6, 27}},
    {0x0fffffe0, {5, 27}},  {0x0ffffff0, {4, 27}},  {0x0ffffff8, {3, 27}},
    {0x0ffffffc, {2, 27}},  {0x0ffffffe, {1, 27}},  {0x0fffffff, {0, 27}},
    {0x1c000000, {26, 28}}, {0x1e000000, {25, 28}}, {0x1f000000, {24, 28}},
    {0x1f800000, {23, 28}}, {0x1fc00000, {22, 28}}, {0x1fe00000, {21, 28}},
    {0x1ff00000, {20, 28}}, {0x1ff80000, {19, 28}}, {0x1ffc0000, {18, 28}},
    {0x1ffe0000, {17, 28}}, {0x1fff0000, {16, 28}}, {0x1fff8000, {15, 28}},
    {0x1fffc000, {14, 28}}, {0x1fffe000, {13, 28}}, {0x1ffff000, {12, 28}},
    {0x1ffff800, {11, 28}}, {0x1ffffc00, {10, 28}}, {0x1ffffe00, {9, 28}},
    {0x1fffff00, {8, 28}},  {0x1fffff80, {7, 28}},  {0x1fffffc0, {6, 28}},
    {0x1fffffe0, {5, 28}},  {0x1ffffff0, {4, 28}},  {0x1ffffff8, {3, 28}},
    {0x1ffffffc, {2, 28}},  {0x1ffffffe, {1, 28}},  {0x1fffffff, {0, 28}},
    {0x38000000, {27, 29}}, {0x3c000000, {26, 29}}, {0x3e000000, {25, 29}},
    {0x3f000000, {24, 29}}, {0x3f800000, {23, 29}}, {0x3fc00000, {22, 29}},
    {0x3fe00000, {21, 29}}, {0x3ff00000, {20, 29}}, {0x3ff80000, {19, 29}},
    {0x3ffc0000, {18, 29}}, {0x3ffe0000, {17, 29}}, {0x3fff0000, {16, 29}},
    {0x3fff8000, {15, 29}}, {0x3fffc000, {14, 29}}, {0x3fffe000, {13, 29}},
    {0x3ffff000, {12, 29}}, {0x3ffff800, {11, 29}}, {0x3ffffc00, {10, 29}},
    {0x3ffffe00, {9, 29}},  {0x3fffff00, {8, 29}},  {0x3fffff80, {7, 29}},
    {0x3fffffc0, {6, 29}},  {0x3fffffe0, {5, 29}},  {0x3ffffff0, {4, 29}},
    {0x3ffffff8, {3, 29}},  {0x3ffffffc, {2, 29}},  {0x3ffffffe, {1, 29}},
    {0x3fffffff, {0, 29}},  {0x70000000, {28, 30}}, {0x78000000, {27, 30}},
    {0x7c000000, {26, 30}}, {0x7e000000, {25, 30}}, {0x7f000000, {24, 30}},
    {0x7f800000, {23, 30}}, {0x7fc00000, {22, 30}}, {0x7fe00000, {21, 30}},
    {0x7ff00000, {20, 30}}, {0x7ff80000, {19, 30}}, {0x7ffc0000, {18, 30}},
    {0x7ffe0000, {17, 30}}, {0x7fff0000, {16, 30}}, {0x7fff8000, {15, 30}},
    {0x7fffc000, {14, 30}}, {0x7fffe000, {13, 30}}, {0x7ffff000, {12, 30}},
    {0x7ffff800, {11, 30}}, {0x7ffffc00, {10, 30}}, {0x7ffffe00, {9, 30}},
    {0x7fffff00, {8, 30}},  {0x7fffff80, {7, 30}},  {0x7fffffc0, {6, 30}},
    {0x7fffffe0, {5, 30}},  {0x7ffffff0, {4, 30}},  {0x7ffffff8, {3, 30}},
    {0x7ffffffc, {2, 30}},  {0x7ffffffe, {1, 30}},  {0x7fffffff, {0, 30}},
    {0x80000003, {31, 1}},  {0x80000007, {31, 2}},  {0x8000000f, {31, 3}},
    {0x8000001f, {31, 4}},  {0x8000003f, {31, 5}},  {0x8000007f, {31, 6}},
    {0x800000ff, {31, 7}},  {0x800001ff, {31, 8}},  {0x800003ff, {31, 9}},
    {0x800007ff, {31, 10}}, {0x80000fff, {31, 11}}, {0x80001fff, {31, 12}},
    {0x80003fff, {31, 13}}, {0x80007fff, {31, 14}}, {0x8000ffff, {31, 15}},
    {0x8001ffff, {31, 16}}, {0x8003ffff, {31, 17}}, {0x8007ffff, {31, 18}},
    {0x800fffff, {31, 19}}, {0x801fffff, {31, 20}}, {0x803fffff, {31, 21}},
    {0x807fffff, {31, 22}}, {0x80ffffff, {31, 23}}, {0x81ffffff, {31, 24}},
    {0x83ffffff, {31, 25}}, {0x87ffffff, {31, 26}}, {0x8fffffff, {31, 27}},
    {0x9fffffff, {31, 28}}, {0xbfffffff, {31, 29}}, {0xc0000001, {30, 0}},
    {0xc0000003, {30, 1}},  {0xc0000007, {30, 2}},  {0xc000000f, {30, 3}},
    {0xc000001f, {30, 4}},  {0xc000003f, {30, 5}},  {0xc000007f, {30, 6}},
    {0xc00000ff, {30, 7}},  {0xc00001ff, {30, 8}},  {0xc00003ff, {30, 9}},
    {0xc00007ff, {30, 10}}, {0xc0000fff, {30, 11}}, {0xc0001fff, {30, 12}},
    {0xc0003fff, {30, 13}}, {0xc0007fff, {30, 14}}, {0xc000ffff, {30, 15}},
    {0xc001ffff, {30, 16}}, {0xc003ffff, {30, 17}}, {0xc007ffff, {30, 18}},
    {0xc00fffff, {30, 19}}, {0xc01fffff, {30, 20}}, {0xc03fffff, {30, 21}},
    {0xc07fffff, {30, 22}}, {0xc0ffffff, {30, 23}}, {0xc1ffffff, {30, 24}},
    {0xc3ffffff, {30, 25}}, {0xc7ffffff, {30, 26}}, {0xcfffffff, {30, 27}},
    {0xdfffffff, {30, 28}}, {0xe0000000, {29, 31}}, {0xe0000001, {29, 0}},
    {0xe0000003, {29, 1}},  {0xe0000007, {29, 2}},  {0xe000000f, {29, 3}},
    {0xe000001f, {29, 4}},  {0xe000003f, {29, 5}},  {0xe000007f, {29, 6}},
    {0xe00000ff, {29, 7}},  {0xe00001ff, {29, 8}},  {0xe00003ff, {29, 9}},
    {0xe00007ff, {29, 10}}, {0xe0000fff, {29, 11}}, {0xe0001fff, {29, 12}},
    {0xe0003fff, {29, 13}}, {0xe0007fff, {29, 14}}, {0xe000ffff, {29, 15}},
    {0xe001ffff, {29, 16}}, {0xe003ffff, {29, 17}}, {0xe007ffff, {29, 18}},
    {0xe00fffff, {29, 19}}, {0xe01fffff, {29, 20}}, {0xe03fffff, {29, 21}},
    {0xe07fffff, {29, 22}}, {0xe0ffffff, {29, 23}}, {0xe1ffffff, {29, 24}},
    {0xe3ffffff, {29, 25}}, {0xe7ffffff, {29, 26}}, {0xefffffff, {29, 27}},
    {0xf0000000, {28, 31}}, {0xf0000001, {28, 0}},  {0xf0000003, {28, 1}},
    {0xf0000007, {28, 2}},  {0xf000000f, {28, 3}},  {0xf000001f, {28, 4}},
    {0xf000003f, {28, 5}},  {0xf000007f, {28, 6}},  {0xf00000ff, {28, 7}},
    {0xf00001ff, {28, 8}},  {0xf00003ff, {28, 9}},  {0xf00007ff, {28, 10}},
    {0xf0000fff, {28, 11}}, {0xf0001fff, {28, 12}}, {0xf0003fff, {28, 13}},
    {0xf0007fff, {28, 14}}, {0xf000ffff, {28, 15}}, {0xf001ffff, {28, 16}},
    {0xf003ffff, {28, 17}}, {0xf007ffff, {28, 18}}, {0xf00fffff, {28, 19}},
    {0xf01fffff, {28, 20}}, {0xf03fffff, {28, 21}}, {0xf07fffff, {28, 22}},
    {0xf0ffffff, {28, 23}}, {0xf1ffffff, {28, 24}}, {0xf3ffffff, {28, 25}},
    {0xf7ffffff, {28, 26}}, {0xf8000000, {27, 31}}, {0xf8000001, {27, 0}},
    {0xf8000003, {27, 1}},  {0xf8000007, {27, 2}},  {0xf800000f, {27, 3}},
    {0xf800001f, {27, 4}},  {0xf800003f, {27, 5}},  {0xf800007f, {27, 6}},
    {0xf80000ff, {27, 7}},  {0xf80001ff, {27, 8}},  {0xf80003ff, {27, 9}},
    {0xf80007ff, {27, 10}}, {0xf8000fff, {27, 11}}, {0xf8001fff, {27, 12}},
    {0xf8003fff, {27, 13}}, {0xf8007fff, {27, 14}}, {0xf800ffff, {27, 15}},
    {0xf801ffff, {27, 16}}, {0xf803ffff, {27, 17}}, {0xf807ffff, {27, 18}},
    {0xf80fffff, {27, 19}}, {0xf81fffff, {27, 20}}, {0xf83fffff, {27, 21}},
    {0xf87fffff, {27, 22}}, {0xf8ffffff, {27, 23}}, {0xf9ffffff, {27, 24}},
    {0xfbffffff, {27, 25}}, {0xfc000000, {26, 31}}, {0xfc000001, {26, 0}},
    {0xfc000003, {26, 1}},  {0xfc000007, {26, 2}},  {0xfc00000f, {26, 3}},
    {0xfc00001f, {26, 4}},  {0xfc00003f, {26, 5}},  {0xfc00007f, {26, 6}},
    {0xfc0000ff, {26, 7}},  {0xfc0001ff, {26, 8}},  {0xfc0003ff, {26, 9}},
    {0xfc0007ff, {26, 10}}, {0xfc000fff, {26, 11}}, {0xfc001fff, {26, 12}},
    {0xfc003fff, {26, 13}}, {0xfc007fff, {26, 14}}, {0xfc00ffff, {26, 15}},
    {0xfc01ffff, {26, 16}}, {0xfc03ffff, {26, 17}}, {0xfc07ffff, {26, 18}},
    {0xfc0fffff, {26, 19}}, {0xfc1fffff, {26, 20}}, {0xfc3fffff, {26, 21}},
    {0xfc7fffff, {26, 22}}, {0xfcffffff, {26, 23}}, {0xfdffffff, {26, 24}},
    {0xfe000000, {25, 31}}, {0xfe000001, {25, 0}},  {0xfe000003, {25, 1}},
    {0xfe000007, {25, 2}},  {0xfe00000f, {25, 3}},  {0xfe00001f, {25, 4}},
    {0xfe00003f, {25, 5}},  {0xfe00007f, {25, 6}},  {0xfe0000ff, {25, 7}},
    {0xfe0001ff, {25, 8}},  {0xfe0003ff, {25, 9}},  {0xfe0007ff, {25, 10}},
    {0xfe000fff, {25, 11}}, {0xfe001fff, {25, 12}}, {0xfe003fff, {25, 13}},
    {0xfe007fff, {25, 14}}, {0xfe00ffff, {25, 15}}, {0xfe01ffff, {25, 16}},
    {0xfe03ffff, {25, 17}}, {0xfe07ffff, {25, 18}}, {0xfe0fffff, {25, 19}},
    {0xfe1fffff, {25, 20}}, {0xfe3fffff, {25, 21}}, {0xfe7fffff, {25, 22}},
    {0xfeffffff, {25, 23}}, {0xff000000, {24, 31}}, {0xff000001, {24, 0}},
    {0xff000003, {24, 1}},  {0xff000007, {24, 2}},  {0xff00000f, {24, 3}},
    {0xff00001f, {24, 4}},  {0xff00003f, {24, 5}},  {0xff00007f, {24, 6}},
    {0xff0000ff, {24, 7}},  {0xff0001ff, {24, 8}},  {0xff0003ff, {24, 9}},
    {0xff0007ff, {24, 10}}, {0xff000fff, {24, 11}}, {0xff001fff, {24, 12}},
    {0xff003fff, {24, 13}}, {0xff007fff, {24, 14}}, {0xff00ffff, {24, 15}},
    {0xff01ffff, {24, 16}}, {0xff03ffff, {24, 17}}, {0xff07ffff, {24, 18}},
    {0xff0fffff, {24, 19}}, {0xff1fffff, {24, 20}}, {0xff3fffff, {24, 21}},
    {0xff7fffff, {24, 22}}, {0xff800000, {23, 31}}, {0xff800001, {23, 0}},
    {0xff800003, {23, 1}},  {0xff800007, {23, 2}},  {0xff80000f, {23, 3}},
    {0xff80001f, {23, 4}},  {0xff80003f, {23, 5}},  {0xff80007f, {23, 6}},
    {0xff8000ff, {23, 7}},  {0xff8001ff, {23, 8}},  {0xff8003ff, {23, 9}},
    {0xff8007ff, {23, 10}}, {0xff800fff, {23, 11}}, {0xff801fff, {23, 12}},
    {0xff803fff, {23, 13}}, {0xff807fff, {23, 14}}, {0xff80ffff, {23, 15}},
    {0xff81ffff, {23, 16}}, {0xff83ffff, {23, 17}}, {0xff87ffff, {23, 18}},
    {0xff8fffff, {23, 19}}, {0xff9fffff, {23, 20}}, {0xffbfffff, {23, 21}},
    {0xffc00000, {22, 31}}, {0xffc00001, {22, 0}},  {0xffc00003, {22, 1}},
    {0xffc00007, {22, 2}},  {0xffc0000f, {22, 3}},  {0xffc0001f, {22, 4}},
    {0xffc0003f, {22, 5}},  {0xffc0007f, {22, 6}},  {0xffc000ff, {22, 7}},
    {0xffc001ff, {22, 8}},  {0xffc003ff, {22, 9}},  {0xffc007ff, {22, 10}},
    {0xffc00fff, {22, 11}}, {0xffc01fff, {22, 12}}, {0xffc03fff, {22, 13}},
    {0xffc07fff, {22, 14}}, {0xffc0ffff, {22, 15}}, {0xffc1ffff, {22, 16}},
    {0xffc3ffff, {22, 17}}, {0xffc7ffff, {22, 18}}, {0xffcfffff, {22, 19}},
    {0xffdfffff, {22, 20}}, {0xffe00000, {21, 31}}, {0xffe00001, {21, 0}},
    {0xffe00003, {21, 1}},  {0xffe00007, {21, 2}},  {0xffe0000f, {21, 3}},
    {0xffe0001f, {21, 4}},  {0xffe0003f, {21, 5}},  {0xffe0007f, {21, 6}},
    {0xffe000ff, {21, 7}},  {0xffe001ff, {21, 8}},  {0xffe003ff, {21, 9}},
    {0xffe007ff, {21, 10}}, {0xffe00fff, {21, 11}}, {0xffe01fff, {21, 12}},
    {0xffe03fff, {21, 13}}, {0xffe07fff, {21, 14}}, {0xffe0ffff, {21, 15}},
    {0xffe1ffff, {21, 16}}, {0xffe3ffff, {21, 17}}, {0xffe7ffff, {21, 18}},
    {0xffefffff, {21, 19}}, {0xfff00000, {20, 31}}, {0xfff00001, {20, 0}},
    {0xfff00003, {20, 1}},  {0xfff00007, {20, 2}},  {0xfff0000f, {20, 3}},
    {0xfff0001f, {20, 4}},  {0xfff0003f, {20, 5}},  {0xfff0007f, {20, 6}},
    {0xfff000ff, {20, 7}},  {0xfff001ff, {20, 8}},  {0xfff003ff, {20, 9}},
    {0xfff007ff, {20, 10}}, {0xfff00fff, {20, 11}}, {0xfff01fff, {20, 12}},
    {0xfff03fff, {20, 13}}, {0xfff07fff, {20, 14}}, {0xfff0ffff, {20, 15}},
    {0xfff1ffff, {20, 16}}, {0xfff3ffff, {20, 17}}, {0xfff7ffff, {20, 18}},
    {0xfff80000, {19, 31}}, {0xfff80001, {19, 0}},  {0xfff80003, {19, 1}},
    {0xfff80007, {19, 2}},  {0xfff8000f, {19, 3}},  {0xfff8001f, {19, 4}},
    {0xfff8003f, {19, 5}},  {0xfff8007f, {19, 6}},  {0xfff800ff, {19, 7}},
    {0xfff801ff, {19, 8}},  {0xfff803ff, {19, 9}},  {0xfff807ff, {19, 10}},
    {0xfff80fff, {19, 11}}, {0xfff81fff, {19, 12}}, {0xfff83fff, {19, 13}},
    {0xfff87fff, {19, 14}}, {0xfff8ffff, {19, 15}}, {0xfff9ffff, {19, 16}},
    {0xfffbffff, {19, 17}}, {0xfffc0000, {18, 31}}, {0xfffc0001, {18, 0}},
    {0xfffc0003, {18, 1}},  {0xfffc0007, {18, 2}},  {0xfffc000f, {18, 3}},
    {0xfffc001f, {18, 4}},  {0xfffc003f, {18, 5}},  {0xfffc007f, {18, 6}},
    {0xfffc00ff, {18, 7}},  {0xfffc01ff, {18, 8}},  {0xfffc03ff, {18, 9}},
    {0xfffc07ff, {18, 10}}, {0xfffc0fff, {18, 11}}, {0xfffc1fff, {18, 12}},
    {0xfffc3fff, {18, 13}}, {0xfffc7fff, {18, 14}}, {0xfffcffff, {18, 15}},
    {0xfffdffff, {18, 16}}, {0xfffe0000, {17, 31}}, {0xfffe0001, {17, 0}},
    {0xfffe0003, {17, 1}},  {0xfffe0007, {17, 2}},  {0xfffe000f, {17, 3}},
    {0xfffe001f, {17, 4}},  {0xfffe003f, {17, 5}},  {0xfffe007f, {17, 6}},
    {0xfffe00ff, {17, 7}},  {0xfffe01ff, {17, 8}},  {0xfffe03ff, {17, 9}},
    {0xfffe07ff, {17, 10}}, {0xfffe0fff, {17, 11}}, {0xfffe1fff, {17, 12}},
    {0xfffe3fff, {17, 13}}, {0xfffe7fff, {17, 14}}, {0xfffeffff, {17, 15}},
    {0xffff0000, {16, 31}}, {0xffff0001, {16, 0}},  {0xffff0003, {16, 1}},
    {0xffff0007, {16, 2}},  {0xffff000f, {16, 3}},  {0xffff001f, {16, 4}},
    {0xffff003f, {16, 5}},  {0xffff007f, {16, 6}},  {0xffff00ff, {16, 7}},
    {0xffff01ff, {16, 8}},  {0xffff03ff, {16, 9}},  {0xffff07ff, {16, 10}},
    {0xffff0fff, {16, 11}}, {0xffff1fff, {16, 12}}, {0xffff3fff, {16, 13}},
    {0xffff7fff, {16, 14}}, {0xffff8000, {15, 31}}, {0xffff8001, {15, 0}},
    {0xffff8003, {15, 1}},  {0xffff8007, {15, 2}},  {0xffff800f, {15, 3}},
    {0xffff801f, {15, 4}},  {0xffff803f, {15, 5}},  {0xffff807f, {15, 6}},
    {0xffff80ff, {15, 7}},  {0xffff81ff, {15, 8}},  {0xffff83ff, {15, 9}},
    {0xffff87ff, {15, 10}}, {0xffff8fff, {15, 11}}, {0xffff9fff, {15, 12}},
    {0xffffbfff, {15, 13}}, {0xffffc000, {14, 31}}, {0xffffc001, {14, 0}},
    {0xffffc003, {14, 1}},  {0xffffc007, {14, 2}},  {0xffffc00f, {14, 3}},
    {0xffffc01f, {14, 4}},  {0xffffc03f, {14, 5}},  {0xffffc07f, {14, 6}},
    {0xffffc0ff, {14, 7}},  {0xffffc1ff, {14, 8}},  {0xffffc3ff, {14, 9}},
    {0xffffc7ff, {14, 10}}, {0xffffcfff, {14, 11}}, {0xffffdfff, {14, 12}},
    {0xffffe000, {13, 31}}, {0xffffe001, {13, 0}},  {0xffffe003, {13, 1}},
    {0xffffe007, {13, 2}},  {0xffffe00f, {13, 3}},  {0xffffe01f, {13, 4}},
    {0xffffe03f, {13, 5}},  {0xffffe07f, {13, 6}},  {0xffffe0ff, {13, 7}},
    {0xffffe1ff, {13, 8}},  {0xffffe3ff, {13, 9}},  {0xffffe7ff, {13, 10}},
    {0xffffefff, {13, 11}}, {0xfffff000, {12, 31}}, {0xfffff001, {12, 0}},
    {0xfffff003, {12, 1}},  {0xfffff007, {12, 2}},  {0xfffff00f, {12, 3}},
    {0xfffff01f, {12, 4}},  {0xfffff03f, {12, 5}},  {0xfffff07f, {12, 6}},
    {0xfffff0ff, {12, 7}},  {0xfffff1ff, {12, 8}},  {0xfffff3ff, {12, 9}},
    {0xfffff7ff, {12, 10}}, {0xfffff800, {11, 31}}, {0xfffff801, {11, 0}},
    {0xfffff803, {11, 1}},  {0xfffff807, {11, 2}},  {0xfffff80f, {11, 3}},
    {0xfffff81f, {11, 4}},  {0xfffff83f, {11, 5}},  {0xfffff87f, {11, 6}},
    {0xfffff8ff, {11, 7}},  {0xfffff9ff, {11, 8}},  {0xfffffbff, {11, 9}},
    {0xfffffc00, {10, 31}}, {0xfffffc01, {10, 0}},  {0xfffffc03, {10, 1}},
    {0xfffffc07, {10, 2}},  {0xfffffc0f, {10, 3}},  {0xfffffc1f, {10, 4}},
    {0xfffffc3f, {10, 5}},  {0xfffffc7f, {10, 6}},  {0xfffffcff, {10, 7}},
    {0xfffffdff, {10, 8}},  {0xfffffe00, {9, 31}},  {0xfffffe01, {9, 0}},
    {0xfffffe03, {9, 1}},   {0xfffffe07, {9, 2}},   {0xfffffe0f, {9, 3}},
    {0xfffffe1f, {9, 4}},   {0xfffffe3f, {9, 5}},   {0xfffffe7f, {9, 6}},
    {0xfffffeff, {9, 7}},   {0xffffff00, {8, 31}},  {0xffffff01, {8, 0}},
    {0xffffff03, {8, 1}},   {0xffffff07, {8, 2}},   {0xffffff0f, {8, 3}},
    {0xffffff1f, {8, 4}},   {0xffffff3f, {8, 5}},   {0xffffff7f, {8, 6}},
    {0xffffff80, {7, 31}},  {0xffffff81, {7, 0}},   {0xffffff83, {7, 1}},
    {0xffffff87, {7, 2}},   {0xffffff8f, {7, 3}},   {0xffffff9f, {7, 4}},
    {0xffffffbf, {7, 5}},   {0xffffffc0, {6, 31}},  {0xffffffc1, {6, 0}},
    {0xffffffc3, {6, 1}},   {0xffffffc7, {6, 2}},   {0xffffffcf, {6, 3}},
    {0xffffffdf, {6, 4}},   {0xffffffe0, {5, 31}},  {0xffffffe1, {5, 0}},
    {0xffffffe3, {5, 1}},   {0xffffffe7, {5, 2}},   {0xffffffef, {5, 3}},
    {0xfffffff0, {4, 31}},  {0xfffffff1, {4, 0}},   {0xfffffff3, {4, 1}},
    {0xfffffff7, {4, 2}},   {0xfffffff8, {3, 31}},  {0xfffffff9, {3, 0}},
    {0xfffffffb, {3, 1}},   {0xfffffffc, {2, 31}},  {0xfffffffd, {2, 0}},
    {0xfffffffe, {1, 31}}};

ASMParser::ASMParser(pair<unsigned, unsigned> lineno,
                     vector<pair<Symbol *, vector<IR *>>> &funcIRs,
                     vector<Symbol *> &consts, vector<Symbol *> &globalVars,
                     unordered_map<Symbol *, vector<Symbol *>> &localVars) {
  this->isProcessed = false;
  this->labelId = 0;
  this->funcIRs = funcIRs;
  this->consts = consts;
  this->globalVars = globalVars;
  this->localVars = localVars;
  this->startLineno = lineno.first;
  this->stopLineno = lineno.second;
}

ASMParser::~ASMParser() {
  for (const pair<Symbol *, vector<ASM *>> &funcASM : funcASMs)
    for (ASM *a : funcASM.second)
      delete a;
}

int ASMParser::calcCallArgSize(const vector<IR *> &irs) {
  int size = 0;
  for (IR *ir : irs)
    if (ir->type == IR::CALL) {
      int iCnt = 0, fCnt = 0;
      for (Symbol *param : ir->items[0]->symbol->params) {
        if (!param->dimensions.empty() || param->dataType == Symbol::INT)
          iCnt++;
        else
          fCnt++;
      }
      size = max(size, max(iCnt - 4, 0) + max(fCnt - 16, 0));
    }
  return size * 4;
}

bool ASMParser::canBeLoadInSingleInstruction(unsigned imm) {
  if (imm <= 0xffff)
    return true;
  if (isByteShiftImm(imm))
    return true;
  if (isByteShiftImm(~imm))
    return true;
  return false;
}

vector<pair<Symbol *, vector<ASM *>>> ASMParser::getFuncASMs() {
  if (!isProcessed)
    parse();
  return funcASMs;
}

unsigned ASMParser::float2Unsigned(float fVal) {
  union {
    float fVal;
    unsigned uVal;
  } unionData;
  unionData.fVal = fVal;
  return unionData.uVal;
}

void ASMParser::loadFromSP(vector<ASM *> &asms, ASMItem::RegType target,
                           unsigned offset) {
  ASM::ASMOpType op = isFloatReg(target) ? ASM::VLDR : ASM::LDR;
  unsigned maxOffset = isFloatReg(target) ? 1020 : 4095;
  if (!offset) {
    asms.push_back(
        new ASM(op, {new ASMItem(target), new ASMItem(ASMItem::SP)}));
    return;
  }
  if (offset <= maxOffset) {
    asms.push_back(new ASM(op, {new ASMItem(target), new ASMItem(ASMItem::SP),
                                new ASMItem(offset)}));
    return;
  }
  loadImmToReg(asms, ASMItem::A4, offset);
  asms.push_back(new ASM(op, {new ASMItem(target), new ASMItem(ASMItem::SP),
                              new ASMItem(ASMItem::A4)}));
}

void ASMParser::loadImmToReg(vector<ASM *> &asms, ASMItem::RegType reg,
                             float val) {
  unsigned data = float2Unsigned(val);
  int exp = (data >> 23) & 0xff;
  if (exp >= 124 && exp <= 131 && !(data & 0x7ffff)) {
    asms.push_back(new ASM(ASM::VMOV, {new ASMItem(reg), new ASMItem(data)}));
    return;
  }
  loadImmToReg(asms, ASMItem::A4, data);
  asms.push_back(
      new ASM(ASM::VMOV, {new ASMItem(reg), new ASMItem(ASMItem::A4)}));
}

void ASMParser::loadImmToReg(vector<ASM *> &asms, ASMItem::RegType reg,
                             unsigned val) {
  if (val <= 0xffff || isByteShiftImm(val)) {
    asms.push_back(new ASM(ASM::MOV, {new ASMItem(reg), new ASMItem(val)}));
    return;
  }
  if (isByteShiftImm(~val)) {
    asms.push_back(new ASM(ASM::MVN, {new ASMItem(reg), new ASMItem(~val)}));
    return;
  }
  asms.push_back(
      new ASM(ASM::MOV, {new ASMItem(reg), new ASMItem(val & 0xffff)}));
  asms.push_back(new ASM(
      ASM::MOVT, {new ASMItem(reg), new ASMItem(((unsigned)val) >> 16)}));
}

void ASMParser::initFrame() {
  savedRegs = 0;
  frameOffset = 0;
  ftemp2Reg.clear();
  itemp2Reg.clear();
  temp2SpillReg.clear();
  spillOffsets.clear();
  offsets.clear();
}

bool ASMParser::isByteShiftImm(unsigned imm) {
  unsigned mask = 0xff;
  for (int i = 0; i < 16; i++) {
    if (!(imm & (~mask)))
      return true;
    mask = (mask << 2) | (mask >> 30);
  }
  return false;
}

bool ASMParser::isFloatImm(float imm) {
  unsigned data = float2Unsigned(imm);
  int exp = (data >> 23) & 0xff;
  return exp >= 124 && exp <= 131 && !(data & 0x7ffff);
}

bool ASMParser::isFloatReg(ASMItem::RegType reg) { return reg >= ASMItem::S0; }

void ASMParser::makeFrame(vector<ASM *> &asms, const vector<IR *> &irs,
                          Symbol *func) {
  RegAllocator *allocator = new RegAllocator(irs);
  usedRegNum = allocator->getUsedRegNum();
  itemp2Reg = allocator->getItemp2Reg();
  ftemp2Reg = allocator->getFtemp2Reg();
  temp2SpillReg = allocator->getTemp2SpillReg();
  delete allocator;
  int callArgSize = calcCallArgSize(irs);
  for (unordered_map<unsigned, unsigned>::iterator it = temp2SpillReg.begin();
       it != temp2SpillReg.end(); it++)
    spillOffsets[it->first] = callArgSize + it->second * 4;
  saveUsedRegs(asms);
  offsets.clear();
  saveArgRegs(asms, func);
  int localVarSize = 0;
  for (Symbol *localVarSymbol : localVars[func]) {
    int size = 4;
    for (int dimension : localVarSymbol->dimensions)
      size *= dimension;
    localVarSize += size;
    offsets[localVarSymbol] = -localVarSize - savedRegs * 4;
  }
  frameOffset = callArgSize + usedRegNum[2] * 4 + localVarSize + savedRegs * 4;
  if ((frameOffset + (usedRegNum[0] + usedRegNum[1]) * 4) % 8 == 0)
    frameOffset += 4;
  for (unordered_map<Symbol *, int>::iterator it = offsets.begin();
       it != offsets.end(); it++)
    it->second += frameOffset;
  moveFromSP(asms, ASMItem::SP, (int)savedRegs * 4 - frameOffset);
}

vector<unsigned> ASMParser::makeSmartImmMask(unsigned imm) {
  const static vector<pair<unsigned, vector<unsigned>>> masks = {
      {0x00000000, {}},
      {0x000000ff, {0x000000ff}},
      {0x000003fc, {0x000003fc}},
      {0x00000ff0, {0x00000ff0}},
      {0x00003fc0, {0x00003fc0}},
      {0x0000ff00, {0x0000ff00}},
      {0x0003fc00, {0x0003fc00}},
      {0x000ff000, {0x000ff000}},
      {0x003fc000, {0x003fc000}},
      {0x00ff0000, {0x00ff0000}},
      {0x03fc0000, {0x03fc0000}},
      {0x0ff00000, {0x0ff00000}},
      {0x3fc00000, {0x3fc00000}},
      {0xc000003f, {0xc000003f}},
      {0xf000000f, {0xf000000f}},
      {0xfc000003, {0xfc000003}},
      {0xff000000, {0xff000000}},
      {0x0000ffff, {0x000000ff, 0x0000ff00}},
      {0x0003fcff, {0x000000ff, 0x0003fc00}},
      {0x0003fffc, {0x000003fc, 0x0003fc00}},
      {0x000ff0ff, {0x000000ff, 0x000ff000}},
      {0x000ff3fc, {0x000003fc, 0x000ff000}},
      {0x000ffff0, {0x00000ff0, 0x000ff000}},
      {0x003fc0ff, {0x000000ff, 0x003fc000}},
      {0x003fc3fc, {0x000003fc, 0x003fc000}},
      {0x003fcff0, {0x00000ff0, 0x003fc000}},
      {0x003fffc0, {0x00003fc0, 0x003fc000}},
      {0x00ff00ff, {0x000000ff, 0x00ff0000}},
      {0x00ff03fc, {0x000003fc, 0x00ff0000}},
      {0x00ff0ff0, {0x00000ff0, 0x00ff0000}},
      {0x00ff3fc0, {0x00003fc0, 0x00ff0000}},
      {0x00ffff00, {0x0000ff00, 0x00ff0000}},
      {0x03fc00ff, {0x000000ff, 0x03fc0000}},
      {0x03fc03fc, {0x000003fc, 0x03fc0000}},
      {0x03fc0ff0, {0x00000ff0, 0x03fc0000}},
      {0x03fc3fc0, {0x00003fc0, 0x03fc0000}},
      {0x03fcff00, {0x0000ff00, 0x03fc0000}},
      {0x03fffc00, {0x0003fc00, 0x03fc0000}},
      {0x0ff000ff, {0x000000ff, 0x0ff00000}},
      {0x0ff003fc, {0x000003fc, 0x0ff00000}},
      {0x0ff00ff0, {0x00000ff0, 0x0ff00000}},
      {0x0ff03fc0, {0x00003fc0, 0x0ff00000}},
      {0x0ff0ff00, {0x0000ff00, 0x0ff00000}},
      {0x0ff3fc00, {0x0003fc00, 0x0ff00000}},
      {0x0ffff000, {0x000ff000, 0x0ff00000}},
      {0x3fc000ff, {0x000000ff, 0x3fc00000}},
      {0x3fc003fc, {0x000003fc, 0x3fc00000}},
      {0x3fc00ff0, {0x00000ff0, 0x3fc00000}},
      {0x3fc03fc0, {0x00003fc0, 0x3fc00000}},
      {0x3fc0ff00, {0x0000ff00, 0x3fc00000}},
      {0x3fc3fc00, {0x0003fc00, 0x3fc00000}},
      {0x3fcff000, {0x000ff000, 0x3fc00000}},
      {0x3fffc000, {0x003fc000, 0x3fc00000}},
      {0xc0003fff, {0x00003fc0, 0xc000003f}},
      {0xc000ff3f, {0x0000ff00, 0xc000003f}},
      {0xc003fc3f, {0x0003fc00, 0xc000003f}},
      {0xc00ff03f, {0x000ff000, 0xc000003f}},
      {0xc03fc03f, {0x003fc000, 0xc000003f}},
      {0xc0ff003f, {0x00ff0000, 0xc000003f}},
      {0xc3fc003f, {0x03fc0000, 0xc000003f}},
      {0xcff0003f, {0x0ff00000, 0xc000003f}},
      {0xf0000fff, {0x00000ff0, 0xf000000f}},
      {0xf0003fcf, {0x00003fc0, 0xf000000f}},
      {0xf000ff0f, {0x0000ff00, 0xf000000f}},
      {0xf003fc0f, {0x0003fc00, 0xf000000f}},
      {0xf00ff00f, {0x000ff000, 0xf000000f}},
      {0xf03fc00f, {0x003fc000, 0xf000000f}},
      {0xf0ff000f, {0x00ff0000, 0xf000000f}},
      {0xf3fc000f, {0x03fc0000, 0xf000000f}},
      {0xfc0003ff, {0x000003fc, 0xfc000003}},
      {0xfc000ff3, {0x00000ff0, 0xfc000003}},
      {0xfc003fc3, {0x00003fc0, 0xfc000003}},
      {0xfc00ff03, {0x0000ff00, 0xfc000003}},
      {0xfc03fc03, {0x0003fc00, 0xfc000003}},
      {0xfc0ff003, {0x000ff000, 0xfc000003}},
      {0xfc3fc003, {0x003fc000, 0xfc000003}},
      {0xfcff0003, {0x00ff0000, 0xfc000003}},
      {0xff0000ff, {0x000000ff, 0xff000000}},
      {0xff0003fc, {0x000003fc, 0xff000000}},
      {0xff000ff0, {0x00000ff0, 0xff000000}},
      {0xff003fc0, {0x00003fc0, 0xff000000}},
      {0xff00ff00, {0x0000ff00, 0xff000000}},
      {0xff03fc00, {0x0003fc00, 0xff000000}},
      {0xff0ff000, {0x000ff000, 0xff000000}},
      {0xff3fc000, {0x003fc000, 0xff000000}},
      {0xffc0003f, {0x3fc00000, 0xc000003f}},
      {0xfff0000f, {0x0ff00000, 0xf000000f}},
      {0xfffc0003, {0x03fc0000, 0xfc000003}},
      {0xffff0000, {0x00ff0000, 0xff000000}},
      {0x00ffffff, {0x000000ff, 0x0000ff00, 0x00ff0000}},
      {0x03fcffff, {0x000000ff, 0x0000ff00, 0x03fc0000}},
      {0x03fffcff, {0x000000ff, 0x0003fc00, 0x03fc0000}},
      {0x03fffffc, {0x000003fc, 0x0003fc00, 0x03fc0000}},
      {0x0ff0ffff, {0x000000ff, 0x0000ff00, 0x0ff00000}},
      {0x0ff3fcff, {0x000000ff, 0x0003fc00, 0x0ff00000}},
      {0x0ff3fffc, {0x000003fc, 0x0003fc00, 0x0ff00000}},
      {0x0ffff0ff, {0x000000ff, 0x000ff000, 0x0ff00000}},
      {0x0ffff3fc, {0x000003fc, 0x000ff000, 0x0ff00000}},
      {0x0ffffff0, {0x00000ff0, 0x000ff000, 0x0ff00000}},
      {0x3fc0ffff, {0x000000ff, 0x0000ff00, 0x3fc00000}},
      {0x3fc3fcff, {0x000000ff, 0x0003fc00, 0x3fc00000}},
      {0x3fc3fffc, {0x000003fc, 0x0003fc00, 0x3fc00000}},
      {0x3fcff0ff, {0x000000ff, 0x000ff000, 0x3fc00000}},
      {0x3fcff3fc, {0x000003fc, 0x000ff000, 0x3fc00000}},
      {0x3fcffff0, {0x00000ff0, 0x000ff000, 0x3fc00000}},
      {0x3fffc0ff, {0x000000ff, 0x003fc000, 0x3fc00000}},
      {0x3fffc3fc, {0x000003fc, 0x003fc000, 0x3fc00000}},
      {0x3fffcff0, {0x00000ff0, 0x003fc000, 0x3fc00000}},
      {0x3fffffc0, {0x00003fc0, 0x003fc000, 0x3fc00000}},
      {0xc03fffff, {0x00003fc0, 0x003fc000, 0xc000003f}},
      {0xc0ff3fff, {0x00003fc0, 0x00ff0000, 0xc000003f}},
      {0xc0ffff3f, {0x0000ff00, 0x00ff0000, 0xc000003f}},
      {0xc3fc3fff, {0x00003fc0, 0x03fc0000, 0xc000003f}},
      {0xc3fcff3f, {0x0000ff00, 0x03fc0000, 0xc000003f}},
      {0xc3fffc3f, {0x0003fc00, 0x03fc0000, 0xc000003f}},
      {0xcff03fff, {0x00003fc0, 0x0ff00000, 0xc000003f}},
      {0xcff0ff3f, {0x0000ff00, 0x0ff00000, 0xc000003f}},
      {0xcff3fc3f, {0x0003fc00, 0x0ff00000, 0xc000003f}},
      {0xcffff03f, {0x000ff000, 0x0ff00000, 0xc000003f}},
      {0xf00fffff, {0x00000ff0, 0x000ff000, 0xf000000f}},
      {0xf03fcfff, {0x00000ff0, 0x003fc000, 0xf000000f}},
      {0xf03fffcf, {0x00003fc0, 0x003fc000, 0xf000000f}},
      {0xf0ff0fff, {0x00000ff0, 0x00ff0000, 0xf000000f}},
      {0xf0ff3fcf, {0x00003fc0, 0x00ff0000, 0xf000000f}},
      {0xf0ffff0f, {0x0000ff00, 0x00ff0000, 0xf000000f}},
      {0xf3fc0fff, {0x00000ff0, 0x03fc0000, 0xf000000f}},
      {0xf3fc3fcf, {0x00003fc0, 0x03fc0000, 0xf000000f}},
      {0xf3fcff0f, {0x0000ff00, 0x03fc0000, 0xf000000f}},
      {0xf3fffc0f, {0x0003fc00, 0x03fc0000, 0xf000000f}},
      {0xfc03ffff, {0x000003fc, 0x0003fc00, 0xfc000003}},
      {0xfc0ff3ff, {0x000003fc, 0x000ff000, 0xfc000003}},
      {0xfc0ffff3, {0x00000ff0, 0x000ff000, 0xfc000003}},
      {0xfc3fc3ff, {0x000003fc, 0x003fc000, 0xfc000003}},
      {0xfc3fcff3, {0x00000ff0, 0x003fc000, 0xfc000003}},
      {0xfc3fffc3, {0x00003fc0, 0x003fc000, 0xfc000003}},
      {0xfcff03ff, {0x000003fc, 0x00ff0000, 0xfc000003}},
      {0xfcff0ff3, {0x00000ff0, 0x00ff0000, 0xfc000003}},
      {0xfcff3fc3, {0x00003fc0, 0x00ff0000, 0xfc000003}},
      {0xfcffff03, {0x0000ff00, 0x00ff0000, 0xfc000003}},
      {0xff00ffff, {0x000000ff, 0x0000ff00, 0xff000000}},
      {0xff03fcff, {0x000000ff, 0x0003fc00, 0xff000000}},
      {0xff03fffc, {0x000003fc, 0x0003fc00, 0xff000000}},
      {0xff0ff0ff, {0x000000ff, 0x000ff000, 0xff000000}},
      {0xff0ff3fc, {0x000003fc, 0x000ff000, 0xff000000}},
      {0xff0ffff0, {0x00000ff0, 0x000ff000, 0xff000000}},
      {0xff3fc0ff, {0x000000ff, 0x003fc000, 0xff000000}},
      {0xff3fc3fc, {0x000003fc, 0x003fc000, 0xff000000}},
      {0xff3fcff0, {0x00000ff0, 0x003fc000, 0xff000000}},
      {0xff3fffc0, {0x00003fc0, 0x003fc000, 0xff000000}},
      {0xffc03fff, {0x00003fc0, 0x3fc00000, 0xc000003f}},
      {0xffc0ff3f, {0x0000ff00, 0x3fc00000, 0xc000003f}},
      {0xffc3fc3f, {0x0003fc00, 0x3fc00000, 0xc000003f}},
      {0xffcff03f, {0x000ff000, 0x3fc00000, 0xc000003f}},
      {0xfff00fff, {0x00000ff0, 0x0ff00000, 0xf000000f}},
      {0xfff03fcf, {0x00003fc0, 0x0ff00000, 0xf000000f}},
      {0xfff0ff0f, {0x0000ff00, 0x0ff00000, 0xf000000f}},
      {0xfff3fc0f, {0x0003fc00, 0x0ff00000, 0xf000000f}},
      {0xfffc03ff, {0x000003fc, 0x03fc0000, 0xfc000003}},
      {0xfffc0ff3, {0x00000ff0, 0x03fc0000, 0xfc000003}},
      {0xfffc3fc3, {0x00003fc0, 0x03fc0000, 0xfc000003}},
      {0xfffcff03, {0x0000ff00, 0x03fc0000, 0xfc000003}},
      {0xffff00ff, {0x000000ff, 0x00ff0000, 0xff000000}},
      {0xffff03fc, {0x000003fc, 0x00ff0000, 0xff000000}},
      {0xffff0ff0, {0x00000ff0, 0x00ff0000, 0xff000000}},
      {0xffff3fc0, {0x00003fc0, 0x00ff0000, 0xff000000}},
      {0xffffc03f, {0x003fc000, 0x3fc00000, 0xc000003f}},
      {0xfffff00f, {0x000ff000, 0x0ff00000, 0xf000000f}},
      {0xfffffc03, {0x0003fc00, 0x03fc0000, 0xfc000003}},
      {0xffffff00, {0x0000ff00, 0x00ff0000, 0xff000000}}};
  for (const pair<unsigned, vector<unsigned>> &mask : masks)
    if (!(imm & ~mask.first))
      return mask.second;
  return {0x000000ff, 0x0000ff00, 0x00ff0000, 0xff000000};
}

void ASMParser::moveFromSP(vector<ASM *> &asms, ASMItem::RegType target,
                           int offset) {
  if (isByteShiftImm(offset))
    asms.push_back(
        new ASM(ASM::ADD, {new ASMItem(target), new ASMItem(ASMItem::SP),
                           new ASMItem(offset)}));
  else if (isByteShiftImm(-offset))
    asms.push_back(
        new ASM(ASM::SUB, {new ASMItem(target), new ASMItem(ASMItem::SP),
                           new ASMItem(-offset)}));
  else if (canBeLoadInSingleInstruction(offset) ||
           canBeLoadInSingleInstruction(-offset)) {
    loadImmToReg(asms, ASMItem::A4, (unsigned)offset);
    asms.push_back(
        new ASM(ASM::ADD, {new ASMItem(target), new ASMItem(ASMItem::SP),
                           new ASMItem(ASMItem::A4)}));
  } else {
    loadImmToReg(asms, ASMItem::A4, (unsigned)(-offset));
    asms.push_back(
        new ASM(ASM::SUB, {new ASMItem(target), new ASMItem(ASMItem::SP),
                           new ASMItem(ASMItem::A4)}));
  }
}

void ASMParser::parse() {
  isProcessed = true;
  preProcess();
  for (const pair<Symbol *, vector<IR *>> &funcIR : funcIRs) {
    vector<ASM *> asms = parseFunc(funcIR.first, funcIR.second);
    funcASMs.emplace_back(funcIR.first, asms);
  }
}

void ASMParser::parseAdd(vector<ASM *> &asms, IR *ir) {
  if (ir->items[1]->type == IRItem::ITEMP &&
      ir->items[2]->type == IRItem::ITEMP)
    parseAddItempItemp(asms, ir);
  else if (ir->items[1]->type == IRItem::ITEMP &&
           ir->items[2]->type == IRItem::INT)
    parseAddItempInt(asms, ir);
  else if (ir->items[1]->type == IRItem::INT &&
           ir->items[2]->type == IRItem::ITEMP) {
    swap(ir->items[1], ir->items[2]);
    parseAddItempInt(asms, ir);
  } else if (ir->items[1]->type == IRItem::FTEMP &&
             ir->items[2]->type == IRItem::FTEMP)
    parseAddFtempFtemp(asms, ir);
  else if (ir->items[1]->type == IRItem::FTEMP &&
           ir->items[2]->type == IRItem::FLOAT)
    parseAddFtempFloat(asms, ir);
  else if (ir->items[1]->type == IRItem::FLOAT &&
           ir->items[2]->type == IRItem::FTEMP) {
    swap(ir->items[1], ir->items[2]);
    parseAddFtempFloat(asms, ir);
  }
}

void ASMParser::parseAddFtempFloat(vector<ASM *> &asms, IR *ir) {
  bool flag1 = ftemp2Reg.find(ir->items[0]->iVal) == ftemp2Reg.end(),
       flag2 = ftemp2Reg.find(ir->items[1]->iVal) == ftemp2Reg.end();
  if (flag2)
    loadFromSP(asms, ASMItem::S1, spillOffsets[ir->items[1]->iVal]);
  if (canBeLoadInSingleInstruction(float2Unsigned(ir->items[2]->fVal)) ||
      !canBeLoadInSingleInstruction(float2Unsigned(-ir->items[2]->fVal))) {
    loadImmToReg(asms, ASMItem::S2, ir->items[2]->fVal);
    asms.push_back(new ASM(
        ASM::VADD,
        {new ASMItem(flag1 ? ASMItem::S0 : ftemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag2 ? ASMItem::S1 : ftemp2Reg[ir->items[1]->iVal]),
         new ASMItem(ASMItem::S2)}));
  } else {
    loadImmToReg(asms, ASMItem::S2, -ir->items[2]->fVal);
    asms.push_back(new ASM(
        ASM::VSUB,
        {new ASMItem(flag1 ? ASMItem::S0 : ftemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag2 ? ASMItem::S1 : ftemp2Reg[ir->items[1]->iVal]),
         new ASMItem(ASMItem::S2)}));
  }
  if (flag1)
    storeFromSP(asms, ASMItem::S0, spillOffsets[ir->items[0]->iVal]);
}

void ASMParser::parseAddFtempFtemp(vector<ASM *> &asms, IR *ir) {
  bool flag1 = ftemp2Reg.find(ir->items[0]->iVal) == ftemp2Reg.end(),
       flag2 = ftemp2Reg.find(ir->items[1]->iVal) == ftemp2Reg.end(),
       flag3 = ftemp2Reg.find(ir->items[2]->iVal) == ftemp2Reg.end();
  if (flag2)
    loadFromSP(asms, ASMItem::S1, spillOffsets[ir->items[1]->iVal]);
  if (flag3)
    loadFromSP(asms, ASMItem::S2, spillOffsets[ir->items[2]->iVal]);
  asms.push_back(new ASM(
      ASM::VADD,
      {new ASMItem(flag1 ? ASMItem::S0 : ftemp2Reg[ir->items[0]->iVal]),
       new ASMItem(flag2 ? ASMItem::S1 : ftemp2Reg[ir->items[1]->iVal]),
       new ASMItem(flag3 ? ASMItem::S2 : ftemp2Reg[ir->items[2]->iVal])}));
  if (flag1)
    storeFromSP(asms, ASMItem::S0, spillOffsets[ir->items[0]->iVal]);
}

void ASMParser::parseAddItempInt(vector<ASM *> &asms, IR *ir) {
  bool flag1 = itemp2Reg.find(ir->items[0]->iVal) == itemp2Reg.end(),
       flag2 = itemp2Reg.find(ir->items[1]->iVal) == itemp2Reg.end();
  if (flag2)
    loadFromSP(asms, ASMItem::A2, spillOffsets[ir->items[1]->iVal]);
  if (isByteShiftImm(ir->items[2]->iVal)) {
    asms.push_back(new ASM(
        ASM::ADD,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(ir->items[2]->iVal)}));
  } else if (isByteShiftImm(-ir->items[2]->iVal)) {
    asms.push_back(new ASM(
        ASM::SUB,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(-ir->items[2]->iVal)}));
  } else if (canBeLoadInSingleInstruction(ir->items[2]->iVal)) {
    loadImmToReg(asms, ASMItem::A3, (unsigned)ir->items[2]->iVal);
    asms.push_back(new ASM(
        ASM::ADD,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(ASMItem::A3)}));
  } else if (canBeLoadInSingleInstruction(-ir->items[2]->iVal)) {
    loadImmToReg(asms, ASMItem::A3, (unsigned)(-ir->items[2]->iVal));
    asms.push_back(new ASM(
        ASM::SUB,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(ASMItem::A3)}));
  } else {
    loadImmToReg(asms, ASMItem::A3, (unsigned)ir->items[2]->iVal);
    asms.push_back(new ASM(
        ASM::ADD,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(ASMItem::A3)}));
  }
  if (flag1)
    storeFromSP(asms, ASMItem::A1, spillOffsets[ir->items[0]->iVal]);
}

void ASMParser::parseAddItempItemp(vector<ASM *> &asms, IR *ir) {
  bool flag1 = itemp2Reg.find(ir->items[0]->iVal) == itemp2Reg.end(),
       flag2 = itemp2Reg.find(ir->items[1]->iVal) == itemp2Reg.end(),
       flag3 = itemp2Reg.find(ir->items[2]->iVal) == itemp2Reg.end();
  if (flag2)
    loadFromSP(asms, ASMItem::A2, spillOffsets[ir->items[1]->iVal]);
  if (flag3)
    loadFromSP(asms, ASMItem::A3, spillOffsets[ir->items[2]->iVal]);
  asms.push_back(new ASM(
      ASM::ADD,
      {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
       new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
       new ASMItem(flag3 ? ASMItem::A3 : itemp2Reg[ir->items[2]->iVal])}));
  if (flag1)
    storeFromSP(asms, ASMItem::A1, spillOffsets[ir->items[0]->iVal]);
}

void ASMParser::parseB(vector<ASM *> &asms, IR *ir) {
  parseLCmp(asms, ir);
  switch (ir->type) {
  case IR::BEQ:
    asms.push_back(
        new ASM(ASM::B, ASM::EQ,
                {new ASMItem(ASMItem::LABEL, irLabels[ir->items[0]->ir])}));
    break;
  case IR::BGE:
    asms.push_back(
        new ASM(ASM::B, ASM::GE,
                {new ASMItem(ASMItem::LABEL, irLabels[ir->items[0]->ir])}));
    break;
  case IR::BGT:
    asms.push_back(
        new ASM(ASM::B, ASM::GT,
                {new ASMItem(ASMItem::LABEL, irLabels[ir->items[0]->ir])}));
    break;
  case IR::BLE:
    asms.push_back(
        new ASM(ASM::B, ASM::LE,
                {new ASMItem(ASMItem::LABEL, irLabels[ir->items[0]->ir])}));
    break;
  case IR::BLT:
    asms.push_back(
        new ASM(ASM::B, ASM::LT,
                {new ASMItem(ASMItem::LABEL, irLabels[ir->items[0]->ir])}));
    break;
  case IR::BNE:
    asms.push_back(
        new ASM(ASM::B, ASM::NE,
                {new ASMItem(ASMItem::LABEL, irLabels[ir->items[0]->ir])}));
    break;
  default:
    break;
  }
}

void ASMParser::parseCall(vector<ASM *> &asms, IR *ir) {
  unsigned iCnt = 0, fCnt = 0, offset = 0;
  for (unsigned i = 1; i < ir->items.size(); i++) {
    if (ir->items[i]->type == IRItem::ITEMP) {
      if (iCnt < 4) {
        iCnt++;
        continue;
      }
      if (itemp2Reg.find(ir->items[i]->iVal) == itemp2Reg.end()) {
        loadFromSP(asms, ASMItem::A1, spillOffsets[ir->items[i]->iVal]);
        storeFromSP(asms, ASMItem::A1, offset);
      } else
        storeFromSP(asms, itemp2Reg[ir->items[i]->iVal], offset);
    } else if (ir->items[i]->type == IRItem::FTEMP) {
      if (fCnt < 16) {
        fCnt++;
        continue;
      }
      if (ftemp2Reg.find(ir->items[i]->iVal) == ftemp2Reg.end()) {
        loadFromSP(asms, ASMItem::A1, spillOffsets[ir->items[i]->iVal]);
        storeFromSP(asms, ASMItem::A1, offset);
      } else
        storeFromSP(asms, ftemp2Reg[ir->items[i]->iVal], offset);
    } else if (ir->items[i]->type == IRItem::INT) {
      if (iCnt < 4) {
        iCnt++;
        continue;
      }
      loadFromSP(asms, ASMItem::A1, ir->items[i]->iVal);
      storeFromSP(asms, ASMItem::A1, offset);
    } else if (ir->items[i]->type == IRItem::FLOAT) {
      if (iCnt < 4) {
        iCnt++;
        continue;
      }
      loadFromSP(asms, ASMItem::S0, ir->items[i]->fVal);
      storeFromSP(asms, ASMItem::S0, offset);
    }
    offset += 4;
  }
  iCnt = 0;
  fCnt = 0;
  for (unsigned i = 1; i < ir->items.size(); i++) {
    if (ir->items[i]->type == IRItem::ITEMP) {
      if (iCnt < 4) {
        if (itemp2Reg.find(ir->items[i]->iVal) == itemp2Reg.end())
          loadFromSP(asms, aIRegs[iCnt++], spillOffsets[ir->items[i]->iVal]);
        else
          asms.push_back(
              new ASM(ASM::MOV, {new ASMItem(aIRegs[iCnt++]),
                                 new ASMItem(itemp2Reg[ir->items[i]->iVal])}));
      }
    } else if (ir->items[i]->type == IRItem::FTEMP) {
      if (fCnt < 16) {
        if (ftemp2Reg.find(ir->items[i]->iVal) == ftemp2Reg.end())
          loadFromSP(asms, aFRegs[fCnt++], spillOffsets[ir->items[i]->iVal]);
        else
          asms.push_back(
              new ASM(ASM::VMOV, {new ASMItem(aFRegs[fCnt++]),
                                  new ASMItem(ftemp2Reg[ir->items[i]->iVal])}));
      }
    } else if (ir->items[i]->type == IRItem::INT) {
      if (iCnt < 4)
        loadImmToReg(asms, aIRegs[iCnt++], (unsigned)ir->items[i]->iVal);
    } else if (ir->items[i]->type == IRItem::FLOAT) {
      if (fCnt < 16)
        loadFromSP(asms, aFRegs[fCnt++], ir->items[i]->fVal);
    }
  }
  if (!ir->items[0]->symbol->name.compare("_sysy_starttime"))
    loadImmToReg(asms, ASMItem::A1, startLineno);
  if (!ir->items[0]->symbol->name.compare("_sysy_stoptime"))
    loadImmToReg(asms, ASMItem::A1, stopLineno);
  asms.push_back(new ASM(ASM::BL, {new ASMItem(ir->items[0]->symbol->name)}));
}

void ASMParser::parseCmp(vector<ASM *> &asms, IR *ir) {
  parseLCmp(asms, ir);
  bool flag1 = itemp2Reg.find(ir->items[0]->iVal) == itemp2Reg.end();
  ASMItem::RegType targetReg =
      flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal];
  switch (ir->type) {
  case IR::EQ:
    asms.push_back(
        new ASM(ASM::MOV, ASM::EQ, {new ASMItem(targetReg), new ASMItem(1)}));
    asms.push_back(
        new ASM(ASM::MOV, ASM::NE, {new ASMItem(targetReg), new ASMItem(0)}));
    break;
  case IR::GE:
    asms.push_back(
        new ASM(ASM::MOV, ASM::GE, {new ASMItem(targetReg), new ASMItem(1)}));
    asms.push_back(
        new ASM(ASM::MOV, ASM::LT, {new ASMItem(targetReg), new ASMItem(0)}));
    break;
  case IR::GT:
    asms.push_back(
        new ASM(ASM::MOV, ASM::GT, {new ASMItem(targetReg), new ASMItem(1)}));
    asms.push_back(
        new ASM(ASM::MOV, ASM::LE, {new ASMItem(targetReg), new ASMItem(0)}));
    break;
  case IR::LE:
    asms.push_back(
        new ASM(ASM::MOV, ASM::LE, {new ASMItem(targetReg), new ASMItem(1)}));
    asms.push_back(
        new ASM(ASM::MOV, ASM::GT, {new ASMItem(targetReg), new ASMItem(0)}));
    break;
  case IR::LT:
    asms.push_back(
        new ASM(ASM::MOV, ASM::LT, {new ASMItem(targetReg), new ASMItem(1)}));
    asms.push_back(
        new ASM(ASM::MOV, ASM::GE, {new ASMItem(targetReg), new ASMItem(0)}));
    break;
  case IR::NE:
    asms.push_back(
        new ASM(ASM::MOV, ASM::NE, {new ASMItem(targetReg), new ASMItem(1)}));
    asms.push_back(
        new ASM(ASM::MOV, ASM::EQ, {new ASMItem(targetReg), new ASMItem(0)}));
    break;
  default:
    break;
  }
  if (flag1)
    storeFromSP(asms, ASMItem::A1, spillOffsets[ir->items[0]->iVal]);
}

void ASMParser::parseDiv(vector<ASM *> &asms, IR *ir) {
  if (ir->items[1]->type == IRItem::ITEMP &&
      ir->items[2]->type == IRItem::ITEMP)
    parseDivItempItemp(asms, ir);
  else if (ir->items[1]->type == IRItem::ITEMP &&
           ir->items[2]->type == IRItem::INT)
    parseDivItempInt(asms, ir);
  else if (ir->items[1]->type == IRItem::INT &&
           ir->items[2]->type == IRItem::ITEMP)
    parseDivIntItemp(asms, ir);
  else if (ir->items[1]->type == IRItem::FTEMP &&
           ir->items[2]->type == IRItem::FTEMP)
    parseDivFtempFtemp(asms, ir);
  else if (ir->items[1]->type == IRItem::FTEMP &&
           ir->items[2]->type == IRItem::FLOAT)
    parseDivFtempFloat(asms, ir);
  else if (ir->items[1]->type == IRItem::FLOAT &&
           ir->items[2]->type == IRItem::FTEMP)
    parseDivFloatFtemp(asms, ir);
}

void ASMParser::parseDivFloatFtemp(vector<ASM *> &asms, IR *ir) {
  bool flag1 = ftemp2Reg.find(ir->items[0]->iVal) == ftemp2Reg.end(),
       flag3 = ftemp2Reg.find(ir->items[2]->iVal) == ftemp2Reg.end();
  loadImmToReg(asms, ASMItem::S1, ir->items[1]->fVal);
  if (flag3)
    loadFromSP(asms, ASMItem::S2, spillOffsets[ir->items[2]->iVal]);
  asms.push_back(new ASM(
      ASM::VDIV,
      {new ASMItem(flag1 ? ASMItem::S0 : ftemp2Reg[ir->items[0]->iVal]),
       new ASMItem(ASMItem::S1),
       new ASMItem(flag3 ? ASMItem::S2 : ftemp2Reg[ir->items[2]->iVal])}));
  if (flag1)
    storeFromSP(asms, ASMItem::S0, spillOffsets[ir->items[0]->iVal]);
}

void ASMParser::parseDivFtempFloat(vector<ASM *> &asms, IR *ir) {
  bool flag1 = ftemp2Reg.find(ir->items[0]->iVal) == ftemp2Reg.end(),
       flag2 = ftemp2Reg.find(ir->items[1]->iVal) == ftemp2Reg.end();
  if (ir->items[2]->fVal == 1.0f) {
    if (flag1 && flag2) {
      loadFromSP(asms, ASMItem::A1, spillOffsets[ir->items[1]->iVal]);
      storeFromSP(asms, ASMItem::A1, spillOffsets[ir->items[0]->iVal]);
    } else if (flag1 && !flag2)
      storeFromSP(asms, ftemp2Reg[ir->items[1]->iVal],
                  spillOffsets[ir->items[0]->iVal]);
    else if (!flag1 && flag2)
      loadFromSP(asms, ftemp2Reg[ir->items[0]->iVal],
                 spillOffsets[ir->items[1]->iVal]);
    else if (!flag1 && !flag2)
      asms.push_back(
          new ASM(ASM::VMOV, {new ASMItem(ftemp2Reg[ir->items[0]->iVal]),
                              new ASMItem(ftemp2Reg[ir->items[0]->iVal])}));
    return;
  }
  if (flag2)
    loadFromSP(asms, ASMItem::S1, spillOffsets[ir->items[1]->iVal]);
  if (ir->items[2]->fVal == -1.0f) {
    if (flag1)
      storeFromSP(asms, flag2 ? ASMItem::S1 : ftemp2Reg[ir->items[1]->iVal],
                  spillOffsets[ir->items[0]->iVal]);
    else
      asms.push_back(new ASM(
          ASM::VNEG,
          {new ASMItem(ftemp2Reg[ir->items[0]->iVal]),
           new ASMItem(flag2 ? ASMItem::S1 : ftemp2Reg[ir->items[1]->iVal])}));
    return;
  }
  loadImmToReg(asms, ASMItem::S2, ir->items[2]->fVal);
  asms.push_back(
      new ASM(ASM::VDIV,
              {new ASMItem(flag1 ? ASMItem::S0 : ftemp2Reg[ir->items[0]->iVal]),
               new ASMItem(flag2 ? ASMItem::S1 : ftemp2Reg[ir->items[1]->iVal]),
               new ASMItem(ASMItem::S2)}));
  if (flag1)
    storeFromSP(asms, ASMItem::S0, spillOffsets[ir->items[0]->iVal]);
}

void ASMParser::parseDivFtempFtemp(vector<ASM *> &asms, IR *ir) {
  bool flag1 = ftemp2Reg.find(ir->items[0]->iVal) == ftemp2Reg.end(),
       flag2 = ftemp2Reg.find(ir->items[1]->iVal) == ftemp2Reg.end(),
       flag3 = ftemp2Reg.find(ir->items[2]->iVal) == ftemp2Reg.end();
  if (flag2)
    loadFromSP(asms, ASMItem::S1, spillOffsets[ir->items[1]->iVal]);
  if (flag3)
    loadFromSP(asms, ASMItem::S2, spillOffsets[ir->items[2]->iVal]);
  asms.push_back(new ASM(
      ASM::VDIV,
      {new ASMItem(flag1 ? ASMItem::S0 : ftemp2Reg[ir->items[0]->iVal]),
       new ASMItem(flag2 ? ASMItem::S1 : ftemp2Reg[ir->items[1]->iVal]),
       new ASMItem(flag3 ? ASMItem::S2 : ftemp2Reg[ir->items[2]->iVal])}));
  if (flag1)
    storeFromSP(asms, ASMItem::S0, spillOffsets[ir->items[0]->iVal]);
}

void ASMParser::parseDivIntItemp(vector<ASM *> &asms, IR *ir) {
  bool flag1 = itemp2Reg.find(ir->items[0]->iVal) == itemp2Reg.end(),
       flag3 = itemp2Reg.find(ir->items[2]->iVal) == itemp2Reg.end();
  loadImmToReg(asms, ASMItem::A2, (unsigned)ir->items[1]->iVal);
  if (flag3)
    loadFromSP(asms, ASMItem::A3, spillOffsets[ir->items[2]->iVal]);
  asms.push_back(new ASM(
      ASM::DIV,
      {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
       new ASMItem(ASMItem::A2),
       new ASMItem(flag3 ? ASMItem::A3 : itemp2Reg[ir->items[2]->iVal])}));
  if (flag1)
    storeFromSP(asms, ASMItem::A1, spillOffsets[ir->items[0]->iVal]);
}

void ASMParser::parseDivItempInt(vector<ASM *> &asms, IR *ir) {
  bool flag1 = itemp2Reg.find(ir->items[0]->iVal) == itemp2Reg.end(),
       flag2 = itemp2Reg.find(ir->items[1]->iVal) == itemp2Reg.end();
  if (flag2)
    loadFromSP(asms, ASMItem::A2, spillOffsets[ir->items[1]->iVal]);
  if (ir->items[2]->iVal == 1)
    asms.push_back(new ASM(
        ASM::MOV,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal])}));
  else if (ir->items[2]->iVal == -1)
    asms.push_back(new ASM(
        ASM::RSB,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(0)}));
  else if (ir->items[2]->iVal == INT32_MIN)
    asms.push_back(new ASM(
        ASM::MOV,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(0)}));
  else if (num2powerMap.find(abs(ir->items[2]->iVal)) != num2powerMap.end()) {
    asms.push_back(new ASM(
        ASM::ASR,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(num2powerMap[ir->items[2]->iVal])}));
    if (ir->items[2]->iVal < 0)
      asms.push_back(new ASM(
          ASM::RSB,
          {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
           new ASMItem(0)}));
  } else {
    unsigned div = ir->items[2]->iVal;
    bool flag = true;
    if (((int)div) < 0) {
      flag = false;
      div = abs(((int)div));
    }
    unsigned shift = 0;
    while (1ull << (shift + 32) <= (0x7fffffff - 0x80000000 % div) *
                                       (div - (1ull << (shift + 32)) % div))
      shift++;
    unsigned magic = (1ull << (shift + 32)) / div + 1;
    loadImmToReg(asms, flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal],
                 magic);
    if (magic <= 0x7fffffff)
      asms.push_back(new ASM(
          ASM::SMMUL,
          {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
           new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal])}));
    else
      asms.push_back(new ASM(
          ASM::SMMLA,
          {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(ASMItem::A2),
           new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal])}));
    if (shift)
      asms.push_back(new ASM(
          ASM::ASR,
          {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(shift)}));
    if (flag && magic <= 0x7fffffff)
      asms.push_back(new ASM(
          ASM::ADD,
          {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
           new ASMItem(ASMItem::LSR, 31)}));
    else if (flag && magic > 0x7fffffff)
      asms.push_back(new ASM(
          ASM::ADD,
          {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(ASMItem::A2), new ASMItem(ASMItem::LSR, 31)}));
    else if (!flag && magic <= 0x7fffffff)
      asms.push_back(new ASM(
          ASM::RSB,
          {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
           new ASMItem(ASMItem::ASR, 31)}));
    else if (!flag && magic > 0x7fffffff)
      asms.push_back(new ASM(
          ASM::RSB,
          {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(ASMItem::A2), new ASMItem(ASMItem::ASR, 31)}));
  }
  if (flag1)
    storeFromSP(asms, ASMItem::A1, spillOffsets[ir->items[0]->iVal]);
}

void ASMParser::parseDivItempItemp(vector<ASM *> &asms, IR *ir) {
  bool flag1 = itemp2Reg.find(ir->items[0]->iVal) == itemp2Reg.end(),
       flag2 = itemp2Reg.find(ir->items[1]->iVal) == itemp2Reg.end(),
       flag3 = itemp2Reg.find(ir->items[2]->iVal) == itemp2Reg.end();
  if (flag2)
    loadFromSP(asms, ASMItem::A2, spillOffsets[ir->items[1]->iVal]);
  if (flag3)
    loadFromSP(asms, ASMItem::A3, spillOffsets[ir->items[2]->iVal]);
  asms.push_back(new ASM(
      ASM::DIV,
      {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
       new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
       new ASMItem(flag3 ? ASMItem::A3 : itemp2Reg[ir->items[2]->iVal])}));
  if (flag1)
    storeFromSP(asms, ASMItem::A1, spillOffsets[ir->items[0]->iVal]);
}

void ASMParser::parseF2I(vector<ASM *> &asms, IR *ir) {
  bool flag1 = itemp2Reg.find(ir->items[0]->iVal) == itemp2Reg.end(),
       flag2 = ftemp2Reg.find(ir->items[1]->iVal) == ftemp2Reg.end();
  if (flag2)
    loadFromSP(asms, ASMItem::S0, spillOffsets[ir->items[1]->iVal]);
  asms.push_back(new ASM(
      ASM::VCVTFS,
      {new ASMItem(flag2 ? ASMItem::S0 : ftemp2Reg[ir->items[1]->iVal]),
       new ASMItem(flag2 ? ASMItem::S0 : ftemp2Reg[ir->items[1]->iVal])}));
  asms.push_back(new ASM(
      ASM::VMOV,
      {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
       new ASMItem(flag2 ? ASMItem::S0 : ftemp2Reg[ir->items[1]->iVal])}));
  if (flag1)
    storeFromSP(asms, ASMItem::A1, spillOffsets[ir->items[0]->iVal]);
}

vector<ASM *> ASMParser::parseFunc(Symbol *func, const vector<IR *> &irs) {
  vector<ASM *> asms;
  initFrame();
  makeFrame(asms, irs, func);
  for (unsigned i = 0; i < irs.size(); i++) {
    switch (irs[i]->type) {
    case IR::ADD:
      parseAdd(asms, irs[i]);
      break;
    case IR::BEQ:
    case IR::BGE:
    case IR::BGT:
    case IR::BLE:
    case IR::BLT:
    case IR::BNE:
      parseB(asms, irs[i]);
      break;
    case IR::CALL:
      parseCall(asms, irs[i]);
      break;
    case IR::DIV:
      parseDiv(asms, irs[i]);
      break;
    case IR::EQ:
    case IR::GE:
    case IR::GT:
    case IR::LE:
    case IR::LT:
    case IR::NE:
      parseCmp(asms, irs[i]);
      break;
    case IR::F2I:
      parseF2I(asms, irs[i]);
      break;
    case IR::GOTO:
      asms.push_back(new ASM(
          ASM::B,
          {new ASMItem(ASMItem::LABEL, irLabels[irs[i]->items[0]->ir])}));
      break;
    case IR::I2F:
      parseI2F(asms, irs[i]);
      break;
    case IR::L_NOT:
      parseLNot(asms, irs[i]);
      break;
    case IR::LABEL:
      asms.push_back(
          new ASM(ASM::LABEL, {new ASMItem(ASMItem::LABEL, irLabels[irs[i]])}));
      break;
    case IR::MEMSET_ZERO:
      parseMemsetZero(asms, irs[i]);
      break;
    case IR::MOD:
      parseMod(asms, irs[i]);
      break;
    case IR::MOV:
      switch (irs[i]->items[0]->type) {
      case IRItem::FTEMP:
        parseMovToFtemp(asms, irs[i]);
        break;
      case IRItem::ITEMP:
        parseMovToItemp(asms, irs[i]);
        break;
      case IRItem::RETURN:
        parseMovToReturn(asms, irs[i]);
        break;
      case IRItem::SYMBOL:
        parseMovToSymbol(asms, irs[i]);
        break;
      default:
        break;
      }
      break;
    case IR::MUL:
      parseMul(asms, irs[i]);
      break;
    case IR::NEG:
      parseNeg(asms, irs[i]);
      break;
    case IR::SUB:
      parseSub(asms, irs[i]);
      break;
    default:
      break;
    }
  }
  moveFromSP(asms, ASMItem::SP, frameOffset);
  popArgs(asms);
  return asms;
}

void ASMParser::parseI2F(vector<ASM *> &asms, IR *ir) {
  bool flag1 = ftemp2Reg.find(ir->items[0]->iVal) == ftemp2Reg.end(),
       flag2 = itemp2Reg.find(ir->items[1]->iVal) == itemp2Reg.end();
  if (flag2)
    loadFromSP(asms, flag1 ? ASMItem::S0 : ftemp2Reg[ir->items[0]->iVal],
               spillOffsets[ir->items[1]->iVal]);
  else
    asms.push_back(new ASM(
        ASM::VMOV,
        {new ASMItem(flag1 ? ASMItem::S0 : ftemp2Reg[ir->items[0]->iVal]),
         new ASMItem(itemp2Reg[ir->items[1]->iVal])}));
  asms.push_back(new ASM(
      ASM::VCVTSF,
      {new ASMItem(flag1 ? ASMItem::S0 : ftemp2Reg[ir->items[0]->iVal]),
       new ASMItem(flag1 ? ASMItem::S0 : ftemp2Reg[ir->items[0]->iVal])}));
  if (flag1)
    storeFromSP(asms, ASMItem::S0, spillOffsets[ir->items[0]->iVal]);
}

void ASMParser::parseLCmp(vector<ASM *> &asms, IR *ir) {
  if (ir->items[1]->type == IRItem::ITEMP &&
      ir->items[2]->type == IRItem::ITEMP)
    parseLCmpItempItemp(asms, ir);
  else if (ir->items[1]->type == IRItem::ITEMP &&
           ir->items[2]->type == IRItem::INT)
    parseLCmpItempInt(asms, ir);
  else if (ir->items[1]->type == IRItem::INT &&
           ir->items[2]->type == IRItem::ITEMP) {
    switchLCmpLogic(ir);
    parseLCmpItempInt(asms, ir);
  } else if (ir->items[1]->type == IRItem::FTEMP &&
             ir->items[2]->type == IRItem::FTEMP)
    parseLCmpFtempFtemp(asms, ir);
  else if (ir->items[1]->type == IRItem::FTEMP &&
           ir->items[2]->type == IRItem::FLOAT)
    parseAddFtempFloat(asms, ir);
  else if (ir->items[1]->type == IRItem::FLOAT &&
           ir->items[2]->type == IRItem::FTEMP) {
    switchLCmpLogic(ir);
    parseAddFtempFloat(asms, ir);
  }
}

void ASMParser::parseLCmpFtempFloat(vector<ASM *> &asms, IR *ir) {
  bool flag2 = ftemp2Reg.find(ir->items[1]->iVal) == ftemp2Reg.end();
  if (flag2)
    loadFromSP(asms, ASMItem::S0, spillOffsets[ir->items[1]->iVal]);
  if (ir->items[2]->fVal) {
    loadImmToReg(asms, ASMItem::S1, ir->items[2]->fVal);
    asms.push_back(new ASM(
        ASM::VCMP,
        {new ASMItem(flag2 ? ASMItem::S0 : ftemp2Reg[ir->items[1]->iVal]),
         new ASMItem(ASMItem::S1)}));
  } else
    asms.push_back(new ASM(
        ASM::VCMP,
        {new ASMItem(flag2 ? ASMItem::S0 : ftemp2Reg[ir->items[1]->iVal]),
         new ASMItem(0.0f)}));
  asms.push_back(new ASM(ASM::VMRS, {}));
}

void ASMParser::parseLCmpFtempFtemp(vector<ASM *> &asms, IR *ir) {
  bool flag2 = ftemp2Reg.find(ir->items[1]->iVal) == ftemp2Reg.end(),
       flag3 = ftemp2Reg.find(ir->items[2]->iVal) == ftemp2Reg.end();
  if (flag2)
    loadFromSP(asms, ASMItem::S0, spillOffsets[ir->items[1]->iVal]);
  if (flag3)
    loadFromSP(asms, ASMItem::S1, spillOffsets[ir->items[2]->iVal]);
  asms.push_back(new ASM(
      ASM::VCMP,
      {new ASMItem(flag2 ? ASMItem::S0 : ftemp2Reg[ir->items[1]->iVal]),
       new ASMItem(flag3 ? ASMItem::S1 : ftemp2Reg[ir->items[2]->iVal])}));
  asms.push_back(new ASM(ASM::VMRS, {}));
}

void ASMParser::parseLCmpItempInt(vector<ASM *> &asms, IR *ir) {
  bool flag = itemp2Reg.find(ir->items[1]->iVal) == itemp2Reg.end();
  if (flag)
    loadFromSP(asms, ASMItem::A1, spillOffsets[ir->items[1]->iVal]);
  if (isByteShiftImm(ir->items[2]->iVal)) {
    loadImmToReg(asms, ASMItem::A2, (unsigned)ir->items[2]->iVal);
    asms.push_back(new ASM(
        ASM::CMP,
        {new ASMItem(flag ? ASMItem::A1 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(ir->items[2]->iVal)}));
  } else if (isByteShiftImm(-ir->items[2]->iVal)) {
    asms.push_back(new ASM(
        ASM::CMN,
        {new ASMItem(flag ? ASMItem::A1 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(-ir->items[2]->iVal)}));
  } else if (canBeLoadInSingleInstruction(ir->items[2]->iVal) ||
             canBeLoadInSingleInstruction(-ir->items[2]->iVal)) {
    loadImmToReg(asms, ASMItem::A2, (unsigned)ir->items[2]->iVal);
    asms.push_back(new ASM(
        ASM::CMP,
        {new ASMItem(flag ? ASMItem::A1 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(ASMItem::A2)}));
  } else {
    loadImmToReg(asms, ASMItem::A2, (unsigned)(-ir->items[2]->iVal));
    asms.push_back(new ASM(
        ASM::CMN,
        {new ASMItem(flag ? ASMItem::A1 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(ASMItem::A2)}));
  }
}

void ASMParser::parseLCmpItempItemp(vector<ASM *> &asms, IR *ir) {
  bool flag1 = itemp2Reg.find(ir->items[1]->iVal) == itemp2Reg.end(),
       flag2 = itemp2Reg.find(ir->items[2]->iVal) == itemp2Reg.end();
  if (flag1)
    loadFromSP(asms, ASMItem::A1, spillOffsets[ir->items[1]->iVal]);
  if (flag2)
    loadFromSP(asms, ASMItem::A2, spillOffsets[ir->items[2]->iVal]);
  asms.push_back(new ASM(
      ASM::CMP,
      {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[1]->iVal]),
       new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[2]->iVal])}));
}

void ASMParser::parseLNot(vector<ASM *> &asms, IR *ir) {
  bool flag1 = itemp2Reg.find(ir->items[0]->iVal) == itemp2Reg.end();
  switch (ir->items[1]->type) {
  case IRItem::ITEMP: {
    bool flag2 = itemp2Reg.find(ir->items[1]->iVal) == itemp2Reg.end();
    ASMItem::RegType targetReg =
        flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal];
    if (flag2) {
      loadFromSP(asms, ASMItem::A1, spillOffsets[ir->items[1]->iVal]);
      asms.push_back(
          new ASM(ASM::CMP, {new ASMItem(ASMItem::A1), new ASMItem(0)}));
    } else
      asms.push_back(
          new ASM(ASM::CMP, {new ASMItem(itemp2Reg[ir->items[1]->iVal]),
                             new ASMItem(0)}));
    asms.push_back(
        new ASM(ASM::MOV, ASM::EQ, {new ASMItem(targetReg), new ASMItem(1)}));
    asms.push_back(
        new ASM(ASM::MOV, ASM::NE, {new ASMItem(targetReg), new ASMItem(0)}));
    if (flag1)
      storeFromSP(asms, ASMItem::A1, spillOffsets[ir->items[0]->iVal]);
    break;
  }
  case IRItem::FTEMP: {
    bool flag2 = ftemp2Reg.find(ir->items[1]->iVal) == ftemp2Reg.end();
    ASMItem::RegType targetReg =
        flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal];
    if (flag2) {
      loadFromSP(asms, ASMItem::S0, spillOffsets[ir->items[1]->iVal]);
      asms.push_back(
          new ASM(ASM::VCMP, {new ASMItem(ASMItem::S0), new ASMItem(0.0f)}));
    } else {
      asms.push_back(
          new ASM(ASM::VCMP, {new ASMItem(ftemp2Reg[ir->items[1]->iVal]),
                              new ASMItem(0.0f)}));
    }
    asms.push_back(new ASM(ASM::VMRS, {}));
    asms.push_back(
        new ASM(ASM::MOV, ASM::EQ, {new ASMItem(targetReg), new ASMItem(1)}));
    asms.push_back(
        new ASM(ASM::MOV, ASM::NE, {new ASMItem(targetReg), new ASMItem(0)}));
    if (flag1)
      storeFromSP(asms, ASMItem::A1, spillOffsets[ir->items[0]->iVal]);
    break;
  }
  default:
    break;
  }
}

void ASMParser::parseMemsetZero(vector<ASM *> &asms, IR *ir) {
  moveFromSP(asms, ASMItem::A1, offsets[ir->items[0]->symbol]);
  asms.push_back(new ASM(ASM::MOV, {new ASMItem(ASMItem::A2), new ASMItem(0)}));
  unsigned size = 4;
  for (int dimension : ir->items[0]->symbol->dimensions)
    size *= dimension;
  loadImmToReg(asms, ASMItem::A3, size);
  asms.push_back(new ASM(ASM::BL, {new ASMItem("memset")}));
}

void ASMParser::parseMod(vector<ASM *> &asms, IR *ir) {
  if (ir->items[1]->type == IRItem::ITEMP &&
      ir->items[2]->type == IRItem::ITEMP)
    parseModItempItemp(asms, ir);
  else if (ir->items[1]->type == IRItem::ITEMP &&
           ir->items[2]->type == IRItem::INT)
    parseModItempInt(asms, ir);
  else if (ir->items[1]->type == IRItem::INT &&
           ir->items[2]->type == IRItem::ITEMP)
    parseModIntItemp(asms, ir);
}

void ASMParser::parseModIntItemp(vector<ASM *> &asms, IR *ir) {
  bool flag1 = itemp2Reg.find(ir->items[0]->iVal) == itemp2Reg.end(),
       flag3 = itemp2Reg.find(ir->items[2]->iVal) == itemp2Reg.end();
  loadImmToReg(asms, ASMItem::A2, (unsigned)ir->items[1]->iVal);
  if (flag3)
    loadFromSP(asms, ASMItem::A3, spillOffsets[ir->items[2]->iVal]);
  asms.push_back(new ASM(
      ASM::DIV,
      {new ASMItem(ASMItem::A1), new ASMItem(ASMItem::A2),
       new ASMItem(flag3 ? ASMItem::A3 : itemp2Reg[ir->items[2]->iVal])}));
  asms.push_back(
      new ASM(ASM::MUL, {new ASMItem(ASMItem::A1), new ASMItem(ASMItem::A1),
                         new ASMItem(ASMItem::A3)}));
  asms.push_back(new ASM(
      ASM::SUB,
      {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
       new ASMItem(ASMItem::A2),
       new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal])}));
  if (flag1)
    storeFromSP(asms, ASMItem::A1, spillOffsets[ir->items[0]->iVal]);
}

void ASMParser::parseModItempInt(vector<ASM *> &asms, IR *ir) {
  bool flag1 = itemp2Reg.find(ir->items[0]->iVal) == itemp2Reg.end(),
       flag2 = itemp2Reg.find(ir->items[1]->iVal) == itemp2Reg.end();
  if (flag2)
    loadFromSP(asms, ASMItem::A2, spillOffsets[ir->items[1]->iVal]);
  if (ir->items[2]->iVal == INT32_MIN) {
    asms.push_back(new ASM(
        ASM::MOV,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal])}));
    asms.push_back(new ASM(
        ASM::CMP,
        {new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(INT32_MIN)}));
    asms.push_back(new ASM(
        ASM::MOV, ASM::EQ,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(0)}));
  } else if (abs(ir->items[2]->iVal) == 1)
    asms.push_back(new ASM(
        ASM::MOV,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(0)}));
  else if (num2powerMap.find(abs(ir->items[2]->iVal)) != num2powerMap.end() &&
           num2powerMap[abs(ir->items[2]->iVal)] <= 8)
    asms.push_back(new ASM(
        ASM::AND,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(abs(ir->items[2]->iVal) - 1)}));
  else if (num2powerMap.find(abs(ir->items[2]->iVal)) != num2powerMap.end() &&
           num2powerMap[abs(ir->items[2]->iVal)] > 8) {
    loadImmToReg(asms, ASMItem::A1, (unsigned)abs(ir->items[2]->iVal) - 1);
    asms.push_back(new ASM(
        ASM::AND,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(ASMItem::A1)}));
  } else {
    unsigned div = abs(ir->items[2]->iVal);
    unsigned shift = 0;
    while (1ull << (shift + 32) <= (0x7fffffff - 0x80000000 % div) *
                                       (div - (1ull << (shift + 32)) % div))
      shift++;
    unsigned magic = (1ull << (shift + 32)) / div + 1;
    loadImmToReg(asms, flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal],
                 magic);
    if (magic <= 0x7fffffff)
      asms.push_back(new ASM(
          ASM::SMMUL,
          {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
           new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal])}));
    else
      asms.push_back(new ASM(
          ASM::SMMLA,
          {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(ASMItem::A2),
           new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal])}));
    if (shift)
      asms.push_back(new ASM(
          ASM::ASR,
          {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(shift)}));
    if (magic <= 0x7fffffff)
      asms.push_back(new ASM(
          ASM::ADD,
          {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
           new ASMItem(ASMItem::LSR, 31)}));
    else
      asms.push_back(new ASM(
          ASM::ADD,
          {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(ASMItem::A2), new ASMItem(ASMItem::LSR, 31)}));
    if (num2power2Map.find(ir->items[2]->iVal) != num2power2Map.end() &&
        (ir->items[2]->iVal & 0x1) == 0x1)
      asms.push_back(new ASM(
          ASM::ADD,
          {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
           new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
           new ASMItem(ASMItem::LSL,
                       num2power2Map[ir->items[2]->iVal].second)}));
    else if (num2power2Map.find(ir->items[2]->iVal) != num2power2Map.end()) {
      asms.push_back(new ASM(
          ASM::ADD,
          {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
           new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
           new ASMItem(ASMItem::LSL,
                       num2power2Map[ir->items[2]->iVal].second)}));
      asms.push_back(new ASM(
          ASM::LSL,
          {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(num2power2Map[ir->items[2]->iVal].first)}));
    } else if (num2rotateMap.find(ir->items[2]->iVal) != num2rotateMap.end()) {
      asms.push_back(new ASM(
          ASM::RSB,
          {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
           new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
           new ASMItem(ASMItem::LSL,
                       num2rotateMap[ir->items[2]->iVal].second -
                           num2rotateMap[ir->items[2]->iVal].first + 1)}));
      asms.push_back(new ASM(
          ASM::LSL,
          {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(num2rotateMap[ir->items[2]->iVal].first)}));
    } else {
      loadImmToReg(asms, ASMItem::A3, (unsigned)ir->items[2]->iVal);
      asms.push_back(new ASM(
          ASM::MUL,
          {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
           new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
           new ASMItem(ASMItem::A3)}));
    }
    asms.push_back(new ASM(
        ASM::SUB,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal])}));
  }
  if (flag1)
    storeFromSP(asms, ASMItem::A1, spillOffsets[ir->items[0]->iVal]);
}

void ASMParser::parseModItempItemp(vector<ASM *> &asms, IR *ir) {
  bool flag1 = itemp2Reg.find(ir->items[0]->iVal) == itemp2Reg.end(),
       flag2 = itemp2Reg.find(ir->items[1]->iVal) == itemp2Reg.end(),
       flag3 = itemp2Reg.find(ir->items[2]->iVal) == itemp2Reg.end();
  if (flag2)
    loadFromSP(asms, ASMItem::A2, spillOffsets[ir->items[1]->iVal]);
  if (flag3)
    loadFromSP(asms, ASMItem::A3, spillOffsets[ir->items[2]->iVal]);
  asms.push_back(new ASM(
      ASM::DIV,
      {new ASMItem(ASMItem::A1),
       new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
       new ASMItem(flag3 ? ASMItem::A3 : itemp2Reg[ir->items[2]->iVal])}));
  asms.push_back(new ASM(
      ASM::MUL,
      {new ASMItem(ASMItem::A1), new ASMItem(ASMItem::A1),
       new ASMItem(flag3 ? ASMItem::A3 : itemp2Reg[ir->items[2]->iVal])}));
  asms.push_back(
      new ASM(ASM::SUB,
              {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
               new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
               new ASMItem(ASMItem::A1)}));
  if (flag1)
    storeFromSP(asms, ASMItem::A1, spillOffsets[ir->items[0]->iVal]);
}

void ASMParser::parseMovToFtemp(vector<ASM *> &asms, IR *ir) {
  switch (ir->items[1]->type) {
  case IRItem::FLOAT:
    if (ftemp2Reg.find(ir->items[0]->iVal) == ftemp2Reg.end()) {
      loadImmToReg(asms, ASMItem::A1, (unsigned)ir->items[1]->iVal);
      storeFromSP(asms, ASMItem::A1, spillOffsets[ir->items[0]->iVal]);
    } else
      loadImmToReg(asms, ftemp2Reg[ir->items[0]->iVal], ir->items[1]->fVal);
    break;
  case IRItem::FTEMP:
    if (ftemp2Reg.find(ir->items[0]->iVal) == ftemp2Reg.end()) {
      if (ftemp2Reg.find(ir->items[1]->iVal) == ftemp2Reg.end()) {
        loadFromSP(asms, ASMItem::A1, spillOffsets[ir->items[1]->iVal]);
        storeFromSP(asms, ASMItem::A1, spillOffsets[ir->items[0]->iVal]);
      } else
        storeFromSP(asms, ftemp2Reg[ir->items[1]->iVal],
                    spillOffsets[ir->items[0]->iVal]);
    } else {
      if (ftemp2Reg.find(ir->items[1]->iVal) == ftemp2Reg.end())
        loadFromSP(asms, ftemp2Reg[ir->items[0]->iVal],
                   spillOffsets[ir->items[1]->iVal]);
      else
        asms.push_back(
            new ASM(ASM::VMOV, {new ASMItem(ftemp2Reg[ir->items[0]->iVal]),
                                new ASMItem(ftemp2Reg[ir->items[1]->iVal])}));
    }
    break;
  case IRItem::RETURN:
    if (ftemp2Reg.find(ir->items[0]->iVal) == ftemp2Reg.end())
      storeFromSP(asms, ASMItem::S0, spillOffsets[ir->items[0]->iVal]);
    else
      asms.push_back(
          new ASM(ASM::VMOV, {new ASMItem(ftemp2Reg[ir->items[0]->iVal]),
                              new ASMItem(ASMItem::S0)}));
    break;
  case IRItem::SYMBOL: {
    vector<unsigned> sizes({4});
    for (int i = ir->items[1]->symbol->dimensions.size() - 1; i > 0; i--)
      sizes.push_back(sizes.back() * ir->items[1]->symbol->dimensions[i]);
    reverse(sizes.begin(), sizes.end());
    unsigned offset = 0;
    vector<pair<unsigned, unsigned>> temps;
    for (unsigned i = 0; i < ir->items.size() - 2; i++) {
      if (ir->items[i + 2]->type == IRItem::INT)
        offset += ir->items[i + 2]->iVal * sizes[i];
      else
        temps.emplace_back(ir->items[i + 2]->iVal, sizes[i]);
    }
    switch (ir->items[1]->symbol->symbolType) {
    case Symbol::CONST:
    case Symbol::GLOBAL_VAR:
      asms.push_back(new ASM(
          ASM::MOVW, {new ASMItem(ASMItem::A2),
                      new ASMItem("#:lower16:" + ir->items[1]->symbol->name)}));
      asms.push_back(new ASM(
          ASM::MOVT, {new ASMItem(ASMItem::A2),
                      new ASMItem("#:upper16:" + ir->items[1]->symbol->name)}));
      break;
    case Symbol::LOCAL_VAR:
      moveFromSP(asms, ASMItem::A2, offsets[ir->items[1]->symbol]);
      break;
    case Symbol::PARAM:
      if (ir->items[1]->symbol->dimensions.empty())
        moveFromSP(asms, ASMItem::A2, offsets[ir->items[1]->symbol]);
      else
        loadFromSP(asms, ASMItem::A2, offsets[ir->items[1]->symbol]);
      break;
    default:
      break;
    }
    for (pair<unsigned, unsigned> temp : temps) {
      if (itemp2Reg.find(temp.first) == itemp2Reg.end()) {
        loadFromSP(asms, ASMItem::A3, spillOffsets[temp.first]);
        loadImmToReg(asms, ASMItem::A4, temp.second);
        asms.push_back(new ASM(ASM::MUL, {new ASMItem(ASMItem::A3),
                                          new ASMItem(ASMItem::A3),
                                          new ASMItem(ASMItem::A4)}));
        asms.push_back(new ASM(ASM::ADD, {new ASMItem(ASMItem::A2),
                                          new ASMItem(ASMItem::A2),
                                          new ASMItem(ASMItem::A3)}));
      } else {
        loadImmToReg(asms, ASMItem::A3, temp.second);
        asms.push_back(new ASM(ASM::MUL, {new ASMItem(ASMItem::A3),
                                          new ASMItem(itemp2Reg[temp.first]),
                                          new ASMItem(ASMItem::A3)}));
        asms.push_back(new ASM(ASM::ADD, {new ASMItem(ASMItem::A2),
                                          new ASMItem(ASMItem::A2),
                                          new ASMItem(ASMItem::A3)}));
      }
    }
    if (offset) {
      loadImmToReg(asms, ASMItem::A3, offset);
      asms.push_back(
          new ASM(ASM::ADD, {new ASMItem(ASMItem::A2), new ASMItem(ASMItem::A2),
                             new ASMItem(ASMItem::A3)}));
    }
    if (ftemp2Reg.find(ir->items[0]->iVal) == ftemp2Reg.end()) {
      asms.push_back(new ASM(
          ASM::LDR, {new ASMItem(ASMItem::A2), new ASMItem(ASMItem::A2)}));
      storeFromSP(asms, ASMItem::A2, spillOffsets[ir->items[0]->iVal]);
    } else
      asms.push_back(
          new ASM(ASM::VLDR, {new ASMItem(ftemp2Reg[ir->items[0]->iVal]),
                              new ASMItem(ASMItem::A2)}));
    break;
  }
  default:
    break;
  }
}

void ASMParser::parseMovToItemp(vector<ASM *> &asms, IR *ir) {
  switch (ir->items[1]->type) {
  case IRItem::INT:
    if (itemp2Reg.find(ir->items[0]->iVal) == itemp2Reg.end()) {
      loadImmToReg(asms, ASMItem::A1, (unsigned)ir->items[1]->iVal);
      storeFromSP(asms, ASMItem::A1, spillOffsets[ir->items[0]->iVal]);
    } else
      loadImmToReg(asms, itemp2Reg[ir->items[0]->iVal],
                   (unsigned)ir->items[1]->iVal);
    break;
  case IRItem::ITEMP:
    if (itemp2Reg.find(ir->items[0]->iVal) == itemp2Reg.end()) {
      if (itemp2Reg.find(ir->items[1]->iVal) == itemp2Reg.end()) {
        loadFromSP(asms, ASMItem::A1, spillOffsets[ir->items[1]->iVal]);
        storeFromSP(asms, ASMItem::A1, spillOffsets[ir->items[0]->iVal]);
      } else
        storeFromSP(asms, itemp2Reg[ir->items[1]->iVal],
                    spillOffsets[ir->items[0]->iVal]);
    } else {
      if (itemp2Reg.find(ir->items[1]->iVal) == itemp2Reg.end())
        loadFromSP(asms, itemp2Reg[ir->items[0]->iVal],
                   spillOffsets[ir->items[1]->iVal]);
      else
        asms.push_back(
            new ASM(ASM::MOV, {new ASMItem(itemp2Reg[ir->items[0]->iVal]),
                               new ASMItem(itemp2Reg[ir->items[1]->iVal])}));
    }
    break;
  case IRItem::RETURN:
    if (itemp2Reg.find(ir->items[0]->iVal) == itemp2Reg.end())
      storeFromSP(asms, ASMItem::A1, spillOffsets[ir->items[0]->iVal]);
    else
      asms.push_back(
          new ASM(ASM::MOV, {new ASMItem(itemp2Reg[ir->items[0]->iVal]),
                             new ASMItem(ASMItem::A1)}));
    break;
  case IRItem::SYMBOL: {
    vector<unsigned> sizes({4});
    for (int i = ir->items[1]->symbol->dimensions.size() - 1; i > 0; i--)
      sizes.push_back(sizes.back() * ir->items[1]->symbol->dimensions[i]);
    reverse(sizes.begin(), sizes.end());
    unsigned offset = 0;
    vector<pair<unsigned, unsigned>> temps;
    for (unsigned i = 0; i < ir->items.size() - 2; i++) {
      if (ir->items[i + 2]->type == IRItem::INT)
        offset += ir->items[i + 2]->iVal * sizes[i];
      else
        temps.emplace_back(ir->items[i + 2]->iVal, sizes[i]);
    }
    switch (ir->items[1]->symbol->symbolType) {
    case Symbol::CONST:
    case Symbol::GLOBAL_VAR:
      asms.push_back(new ASM(
          ASM::MOVW, {new ASMItem(ASMItem::A2),
                      new ASMItem("#:lower16:" + ir->items[1]->symbol->name)}));
      asms.push_back(new ASM(
          ASM::MOVT, {new ASMItem(ASMItem::A2),
                      new ASMItem("#:upper16:" + ir->items[1]->symbol->name)}));
      break;
    case Symbol::LOCAL_VAR:
      moveFromSP(asms, ASMItem::A2, offsets[ir->items[1]->symbol]);
      break;
    case Symbol::PARAM:
      if (ir->items[1]->symbol->dimensions.empty())
        moveFromSP(asms, ASMItem::A2, offsets[ir->items[1]->symbol]);
      else
        loadFromSP(asms, ASMItem::A2, offsets[ir->items[1]->symbol]);
      break;
    default:
      break;
    }
    for (pair<unsigned, unsigned> temp : temps) {
      if (itemp2Reg.find(temp.first) == itemp2Reg.end()) {
        loadFromSP(asms, ASMItem::A3, spillOffsets[temp.first]);
        loadImmToReg(asms, ASMItem::A4, temp.second);
        asms.push_back(new ASM(ASM::MUL, {new ASMItem(ASMItem::A3),
                                          new ASMItem(ASMItem::A3),
                                          new ASMItem(ASMItem::A4)}));
        asms.push_back(new ASM(ASM::ADD, {new ASMItem(ASMItem::A2),
                                          new ASMItem(ASMItem::A2),
                                          new ASMItem(ASMItem::A3)}));
      } else {
        loadImmToReg(asms, ASMItem::A3, temp.second);
        asms.push_back(new ASM(ASM::MUL, {new ASMItem(ASMItem::A3),
                                          new ASMItem(itemp2Reg[temp.first]),
                                          new ASMItem(ASMItem::A3)}));
        asms.push_back(new ASM(ASM::ADD, {new ASMItem(ASMItem::A2),
                                          new ASMItem(ASMItem::A2),
                                          new ASMItem(ASMItem::A3)}));
      }
    }
    if (offset) {
      loadImmToReg(asms, ASMItem::A3, offset);
      asms.push_back(
          new ASM(ASM::ADD, {new ASMItem(ASMItem::A2), new ASMItem(ASMItem::A2),
                             new ASMItem(ASMItem::A3)}));
    }
    if (ir->items[1]->symbol->dimensions.size() + 2 == ir->items.size())
      asms.push_back(new ASM(
          ASM::LDR, {new ASMItem(ASMItem::A2), new ASMItem(ASMItem::A2)}));
    if (itemp2Reg.find(ir->items[0]->iVal) == itemp2Reg.end())
      storeFromSP(asms, ASMItem::A2, spillOffsets[ir->items[0]->iVal]);
    else
      asms.push_back(
          new ASM(ASM::MOV, {new ASMItem(itemp2Reg[ir->items[0]->iVal]),
                             new ASMItem(ASMItem::A2)}));
    break;
  }
  default:
    break;
  }
}

void ASMParser::parseMovToReturn(vector<ASM *> &asms, IR *ir) {
  switch (ir->items[1]->type) {
  case IRItem::ITEMP:
    if (itemp2Reg.find(ir->items[1]->iVal) == itemp2Reg.end())
      loadFromSP(asms, ASMItem::A1, spillOffsets[ir->items[1]->iVal]);
    else
      asms.push_back(
          new ASM(ASM::MOV, {new ASMItem(ASMItem::A1),
                             new ASMItem(itemp2Reg[ir->items[1]->iVal])}));
    break;
  case IRItem::FTEMP:
    if (ftemp2Reg.find(ir->items[1]->iVal) == ftemp2Reg.end())
      loadFromSP(asms, ASMItem::S0, spillOffsets[ir->items[1]->iVal]);
    else
      asms.push_back(
          new ASM(ASM::VMOV, {new ASMItem(ASMItem::S0),
                              new ASMItem(ftemp2Reg[ir->items[1]->iVal])}));
    break;
  case IRItem::INT:
    loadImmToReg(asms, ASMItem::A1, (unsigned)ir->items[1]->iVal);
    break;
  case IRItem::FLOAT:
    loadImmToReg(asms, ASMItem::S0, ir->items[1]->fVal);
    break;
  case IRItem::SYMBOL: {
    vector<unsigned> sizes({4});
    for (int i = ir->items[1]->symbol->dimensions.size() - 1; i > 0; i--)
      sizes.push_back(sizes.back() * ir->items[1]->symbol->dimensions[i]);
    reverse(sizes.begin(), sizes.end());
    unsigned offset = 0;
    vector<pair<unsigned, unsigned>> temps;
    for (unsigned i = 0; i < ir->items.size() - 2; i++) {
      if (ir->items[i + 2]->type == IRItem::INT)
        offset += ir->items[i + 2]->iVal * sizes[i];
      else
        temps.emplace_back(ir->items[i + 2]->iVal, sizes[i]);
    }
    switch (ir->items[1]->symbol->symbolType) {
    case Symbol::CONST:
    case Symbol::GLOBAL_VAR:
      asms.push_back(new ASM(
          ASM::MOVW, {new ASMItem(ASMItem::A2),
                      new ASMItem("#:lower16:" + ir->items[1]->symbol->name)}));
      asms.push_back(new ASM(
          ASM::MOVT, {new ASMItem(ASMItem::A2),
                      new ASMItem("#:upper16:" + ir->items[1]->symbol->name)}));
      break;
    case Symbol::LOCAL_VAR:
      moveFromSP(asms, ASMItem::A2, offsets[ir->items[1]->symbol]);
      break;
    case Symbol::PARAM:
      if (ir->items[1]->symbol->dimensions.empty())
        moveFromSP(asms, ASMItem::A2, offsets[ir->items[1]->symbol]);
      else
        loadFromSP(asms, ASMItem::A2, offsets[ir->items[1]->symbol]);
      break;
    default:
      break;
    }
    for (pair<unsigned, unsigned> temp : temps) {
      if (itemp2Reg.find(temp.first) == itemp2Reg.end()) {
        loadFromSP(asms, ASMItem::A3, spillOffsets[temp.first]);
        loadImmToReg(asms, ASMItem::A4, temp.second);
        asms.push_back(new ASM(ASM::MUL, {new ASMItem(ASMItem::A3),
                                          new ASMItem(ASMItem::A3),
                                          new ASMItem(ASMItem::A4)}));
        asms.push_back(new ASM(ASM::ADD, {new ASMItem(ASMItem::A2),
                                          new ASMItem(ASMItem::A2),
                                          new ASMItem(ASMItem::A3)}));
      } else {
        loadImmToReg(asms, ASMItem::A3, temp.second);
        asms.push_back(new ASM(ASM::MUL, {new ASMItem(ASMItem::A3),
                                          new ASMItem(itemp2Reg[temp.first]),
                                          new ASMItem(ASMItem::A3)}));
        asms.push_back(new ASM(ASM::ADD, {new ASMItem(ASMItem::A2),
                                          new ASMItem(ASMItem::A2),
                                          new ASMItem(ASMItem::A3)}));
      }
    }
    if (offset) {
      loadImmToReg(asms, ASMItem::A3, offset);
      asms.push_back(
          new ASM(ASM::ADD, {new ASMItem(ASMItem::A2), new ASMItem(ASMItem::A2),
                             new ASMItem(ASMItem::A3)}));
    }
    if (ir->items[1]->symbol->dataType == Symbol::INT)
      asms.push_back(new ASM(
          ASM::LDR, {new ASMItem(ASMItem::A1), new ASMItem(ASMItem::A2)}));
    else
      asms.push_back(new ASM(
          ASM::VLDR, {new ASMItem(ASMItem::S0), new ASMItem(ASMItem::A2)}));
    break;
  }
  default:
    break;
  }
}

void ASMParser::parseMovToSymbol(vector<ASM *> &asms, IR *ir) {
  vector<unsigned> sizes({4});
  for (int i = ir->items[0]->symbol->dimensions.size() - 1; i > 0; i--)
    sizes.push_back(sizes.back() * ir->items[0]->symbol->dimensions[i]);
  reverse(sizes.begin(), sizes.end());
  unsigned offset = 0;
  vector<pair<unsigned, unsigned>> temps;
  for (unsigned i = 0; i < ir->items.size() - 2; i++) {
    if (ir->items[i + 2]->type == IRItem::INT)
      offset += ir->items[i + 2]->iVal * sizes[i];
    else
      temps.emplace_back(ir->items[i + 2]->iVal, sizes[i]);
  }
  switch (ir->items[0]->symbol->symbolType) {
  case Symbol::CONST:
  case Symbol::GLOBAL_VAR:
    asms.push_back(new ASM(
        ASM::MOVW, {new ASMItem(ASMItem::A2),
                    new ASMItem("#:lower16:" + ir->items[0]->symbol->name)}));
    asms.push_back(new ASM(
        ASM::MOVT, {new ASMItem(ASMItem::A2),
                    new ASMItem("#:upper16:" + ir->items[0]->symbol->name)}));
    break;
  case Symbol::LOCAL_VAR:
    moveFromSP(asms, ASMItem::A2, offsets[ir->items[0]->symbol]);
    break;
  case Symbol::PARAM:
    if (ir->items[0]->symbol->dimensions.empty())
      moveFromSP(asms, ASMItem::A2, offsets[ir->items[0]->symbol]);
    else
      loadFromSP(asms, ASMItem::A2, offsets[ir->items[0]->symbol]);
    break;
  default:
    break;
  }
  for (pair<unsigned, unsigned> temp : temps) {
    if (itemp2Reg.find(temp.first) == itemp2Reg.end()) {
      loadFromSP(asms, ASMItem::A3, spillOffsets[temp.first]);
      loadImmToReg(asms, ASMItem::A4, temp.second);
      asms.push_back(
          new ASM(ASM::MUL, {new ASMItem(ASMItem::A3), new ASMItem(ASMItem::A3),
                             new ASMItem(ASMItem::A4)}));
      asms.push_back(
          new ASM(ASM::ADD, {new ASMItem(ASMItem::A2), new ASMItem(ASMItem::A2),
                             new ASMItem(ASMItem::A3)}));
    } else {
      loadImmToReg(asms, ASMItem::A3, temp.second);
      asms.push_back(new ASM(ASM::MUL, {new ASMItem(ASMItem::A3),
                                        new ASMItem(itemp2Reg[temp.first]),
                                        new ASMItem(ASMItem::A3)}));
      asms.push_back(
          new ASM(ASM::ADD, {new ASMItem(ASMItem::A2), new ASMItem(ASMItem::A2),
                             new ASMItem(ASMItem::A3)}));
    }
  }
  if (offset) {
    loadImmToReg(asms, ASMItem::A3, offset);
    asms.push_back(
        new ASM(ASM::ADD, {new ASMItem(ASMItem::A2), new ASMItem(ASMItem::A2),
                           new ASMItem(ASMItem::A3)}));
  }
  switch (ir->items[1]->type) {
  case IRItem::ITEMP:
    if (itemp2Reg.find(ir->items[1]->iVal) == itemp2Reg.end()) {
      loadFromSP(asms, ASMItem::A3, spillOffsets[ir->items[1]->iVal]);
      asms.push_back(new ASM(
          ASM::STR, {new ASMItem(ASMItem::A3), new ASMItem(ASMItem::A2)}));
    } else
      asms.push_back(
          new ASM(ASM::STR, {new ASMItem(itemp2Reg[ir->items[1]->iVal]),
                             new ASMItem(ASMItem::A2)}));
    break;
  case IRItem::FTEMP:
    if (ftemp2Reg.find(ir->items[1]->iVal) == ftemp2Reg.end()) {
      loadFromSP(asms, ASMItem::A3, spillOffsets[ir->items[1]->iVal]);
      asms.push_back(new ASM(
          ASM::STR, {new ASMItem(ASMItem::A3), new ASMItem(ASMItem::A2)}));
    } else
      asms.push_back(
          new ASM(ASM::VSTR, {new ASMItem(ftemp2Reg[ir->items[1]->iVal]),
                              new ASMItem(ASMItem::A2)}));
    break;
  case IRItem::INT:
  case IRItem::FLOAT:
    loadImmToReg(asms, ASMItem::A3, (unsigned)ir->items[1]->iVal);
    asms.push_back(new ASM(
        ASM::STR, {new ASMItem(ASMItem::A3), new ASMItem(ASMItem::A2)}));
    break;
  case IRItem::RETURN:
    if (ir->items[0]->symbol->dataType == Symbol::FLOAT)
      asms.push_back(new ASM(
          ASM::VSTR, {new ASMItem(ASMItem::S0), new ASMItem(ASMItem::A2)}));
    else
      asms.push_back(new ASM(
          ASM::STR, {new ASMItem(ASMItem::A1), new ASMItem(ASMItem::A2)}));
    break;
  default:
    break;
  }
}

void ASMParser::parseMul(vector<ASM *> &asms, IR *ir) {
  if (ir->items[1]->type == IRItem::ITEMP &&
      ir->items[2]->type == IRItem::ITEMP)
    parseMulItempItemp(asms, ir);
  else if (ir->items[1]->type == IRItem::ITEMP &&
           ir->items[2]->type == IRItem::INT)
    parseMulItempInt(asms, ir);
  else if (ir->items[1]->type == IRItem::INT &&
           ir->items[2]->type == IRItem::ITEMP) {
    swap(ir->items[1], ir->items[2]);
    parseMulItempInt(asms, ir);
  } else if (ir->items[1]->type == IRItem::FTEMP &&
             ir->items[2]->type == IRItem::FTEMP)
    parseMulFtempFtemp(asms, ir);
  else if (ir->items[1]->type == IRItem::FTEMP &&
           ir->items[2]->type == IRItem::FLOAT)
    parseMulFtempFloat(asms, ir);
  else if (ir->items[1]->type == IRItem::FLOAT &&
           ir->items[2]->type == IRItem::FTEMP)
    parseMulFloatFtemp(asms, ir);
}

void ASMParser::parseMulFloatFtemp(vector<ASM *> &asms, IR *ir) {
  bool flag1 = ftemp2Reg.find(ir->items[0]->iVal) == ftemp2Reg.end(),
       flag3 = ftemp2Reg.find(ir->items[2]->iVal) == ftemp2Reg.end();
  loadImmToReg(asms, ASMItem::S1, ir->items[1]->fVal);
  if (flag3)
    loadFromSP(asms, ASMItem::S2, spillOffsets[ir->items[2]->iVal]);
  asms.push_back(new ASM(
      ASM::VMUL,
      {new ASMItem(flag1 ? ASMItem::S0 : ftemp2Reg[ir->items[0]->iVal]),
       new ASMItem(ASMItem::S1),
       new ASMItem(flag3 ? ASMItem::S2 : ftemp2Reg[ir->items[2]->iVal])}));
  if (flag1)
    storeFromSP(asms, ASMItem::S0, spillOffsets[ir->items[0]->iVal]);
}

void ASMParser::parseMulFtempFloat(vector<ASM *> &asms, IR *ir) {
  bool flag1 = ftemp2Reg.find(ir->items[0]->iVal) == ftemp2Reg.end(),
       flag2 = ftemp2Reg.find(ir->items[1]->iVal) == ftemp2Reg.end();
  if (flag2)
    loadFromSP(asms, ASMItem::S1, spillOffsets[ir->items[1]->iVal]);
  loadImmToReg(asms, ASMItem::S2, ir->items[2]->fVal);
  asms.push_back(
      new ASM(ASM::VMUL,
              {new ASMItem(flag1 ? ASMItem::S0 : ftemp2Reg[ir->items[0]->iVal]),
               new ASMItem(flag2 ? ASMItem::S1 : ftemp2Reg[ir->items[1]->iVal]),
               new ASMItem(ASMItem::S2)}));
  if (flag1)
    storeFromSP(asms, ASMItem::S0, spillOffsets[ir->items[0]->iVal]);
}

void ASMParser::parseMulFtempFtemp(vector<ASM *> &asms, IR *ir) {
  bool flag1 = ftemp2Reg.find(ir->items[0]->iVal) == ftemp2Reg.end(),
       flag2 = ftemp2Reg.find(ir->items[1]->iVal) == ftemp2Reg.end(),
       flag3 = ftemp2Reg.find(ir->items[2]->iVal) == ftemp2Reg.end();
  if (flag2)
    loadFromSP(asms, ASMItem::S1, spillOffsets[ir->items[1]->iVal]);
  if (flag3)
    loadFromSP(asms, ASMItem::S2, spillOffsets[ir->items[2]->iVal]);
  asms.push_back(new ASM(
      ASM::VMUL,
      {new ASMItem(flag1 ? ASMItem::S0 : ftemp2Reg[ir->items[0]->iVal]),
       new ASMItem(flag2 ? ASMItem::S1 : ftemp2Reg[ir->items[1]->iVal]),
       new ASMItem(flag3 ? ASMItem::S2 : ftemp2Reg[ir->items[2]->iVal])}));
  if (flag1)
    storeFromSP(asms, ASMItem::S0, spillOffsets[ir->items[0]->iVal]);
}

void ASMParser::parseMulItempInt(vector<ASM *> &asms, IR *ir) {
  bool flag1 = itemp2Reg.find(ir->items[0]->iVal) == itemp2Reg.end(),
       flag2 = itemp2Reg.find(ir->items[1]->iVal) == itemp2Reg.end();
  if (flag2)
    loadFromSP(asms, ASMItem::A2, spillOffsets[ir->items[1]->iVal]);
  if (!ir->items[2]->iVal)
    loadImmToReg(asms, flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal], 0u);
  else if (ir->items[2]->iVal == 1)
    asms.push_back(new ASM(
        ASM::MOV,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal])}));
  else if (ir->items[2]->iVal == -1)
    asms.push_back(new ASM(
        ASM::RSB,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(0)}));
  else if (num2powerMap.find(ir->items[2]->iVal) != num2powerMap.end())
    asms.push_back(new ASM(
        ASM::LSL,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(num2powerMap[ir->items[2]->iVal])}));
  else if (num2power2Map.find(ir->items[2]->iVal) != num2power2Map.end() &&
           (ir->items[2]->iVal & 0x1) == 0x1)
    asms.push_back(new ASM(
        ASM::ADD,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(ASMItem::LSL, num2power2Map[ir->items[2]->iVal].second)}));
  else if (num2rotateMap.find(ir->items[2]->iVal) != num2rotateMap.end() &&
           (ir->items[2]->iVal & 0x80000001) == 0x80000001)
    asms.push_back(new ASM(
        ASM::RSB,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(ASMItem::LSL,
                     num2rotateMap[ir->items[2]->iVal].second + 2)}));
  else if (num2rotateMap.find(ir->items[2]->iVal) != num2rotateMap.end() &&
           (ir->items[2]->iVal & 0x3) == 0x1)
    asms.push_back(new ASM(
        ASM::SUB,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(ASMItem::LSL, num2rotateMap[ir->items[2]->iVal].first)}));
  else if (num2power2Map.find(ir->items[2]->iVal) != num2power2Map.end()) {
    asms.push_back(new ASM(
        ASM::ADD,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(ASMItem::LSL, num2power2Map[ir->items[2]->iVal].second)}));
    asms.push_back(new ASM(
        ASM::LSL,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(num2power2Map[ir->items[2]->iVal].first)}));
  } else if (num2rotateMap.find(ir->items[2]->iVal) != num2rotateMap.end()) {
    asms.push_back(new ASM(
        ASM::RSB,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(ASMItem::LSL,
                     (num2rotateMap[ir->items[2]->iVal].second -
                      num2rotateMap[ir->items[2]->iVal].first + 33) %
                         32)}));
    asms.push_back(new ASM(
        ASM::ROR,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(32 - num2rotateMap[ir->items[2]->iVal].first)}));
  } else {
    loadImmToReg(asms, ASMItem::A3, (unsigned)ir->items[2]->iVal);
    asms.push_back(new ASM(
        ASM::MUL,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(ASMItem::A3)}));
  }
  if (flag1)
    storeFromSP(asms, ASMItem::A1, spillOffsets[ir->items[0]->iVal]);
}

void ASMParser::parseMulItempItemp(vector<ASM *> &asms, IR *ir) {
  bool flag1 = itemp2Reg.find(ir->items[0]->iVal) == itemp2Reg.end(),
       flag2 = itemp2Reg.find(ir->items[1]->iVal) == itemp2Reg.end(),
       flag3 = itemp2Reg.find(ir->items[2]->iVal) == itemp2Reg.end();
  if (flag2)
    loadFromSP(asms, ASMItem::A2, spillOffsets[ir->items[1]->iVal]);
  if (flag3)
    loadFromSP(asms, ASMItem::A3, spillOffsets[ir->items[2]->iVal]);
  asms.push_back(new ASM(
      ASM::MUL,
      {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
       new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
       new ASMItem(flag3 ? ASMItem::A3 : itemp2Reg[ir->items[2]->iVal])}));
  if (flag1)
    storeFromSP(asms, ASMItem::A1, spillOffsets[ir->items[0]->iVal]);
}

void ASMParser::parseNeg(vector<ASM *> &asms, IR *ir) {
  if (ir->items[0]->type == IRItem::ITEMP &&
      ir->items[1]->type == IRItem::ITEMP) {
    bool flag1 = itemp2Reg.find(ir->items[0]->iVal) == itemp2Reg.end(),
         flag2 = itemp2Reg.find(ir->items[1]->iVal) == itemp2Reg.end();
    if (flag2)
      loadFromSP(asms, ASMItem::A2, spillOffsets[ir->items[1]->iVal]);
    asms.push_back(new ASM(
        ASM::RSB,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(0)}));
    if (flag1)
      storeFromSP(asms, ASMItem::A1, spillOffsets[ir->items[0]->iVal]);
  } else if (ir->items[0]->type == IRItem::FTEMP &&
             ir->items[1]->type == IRItem::FTEMP) {
    bool flag1 = ftemp2Reg.find(ir->items[0]->iVal) == ftemp2Reg.end(),
         flag2 = ftemp2Reg.find(ir->items[1]->iVal) == ftemp2Reg.end();
    if (flag2)
      loadFromSP(asms, ASMItem::S1, spillOffsets[ir->items[1]->iVal]);
    asms.push_back(new ASM(
        ASM::VNEG,
        {new ASMItem(flag1 ? ASMItem::S0 : ftemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag2 ? ASMItem::S1 : ftemp2Reg[ir->items[1]->iVal])}));
    if (flag1)
      storeFromSP(asms, ASMItem::S0, spillOffsets[ir->items[0]->iVal]);
  }
}

void ASMParser::parseSub(vector<ASM *> &asms, IR *ir) {
  if (ir->items[1]->type == IRItem::ITEMP &&
      ir->items[2]->type == IRItem::ITEMP) {
    bool flag1 = itemp2Reg.find(ir->items[0]->iVal) == itemp2Reg.end(),
         flag2 = itemp2Reg.find(ir->items[1]->iVal) == itemp2Reg.end(),
         flag3 = itemp2Reg.find(ir->items[2]->iVal) == itemp2Reg.end();
    if (flag2)
      loadFromSP(asms, ASMItem::A2, spillOffsets[ir->items[1]->iVal]);
    if (flag3)
      loadFromSP(asms, ASMItem::A3, spillOffsets[ir->items[2]->iVal]);
    asms.push_back(new ASM(
        ASM::SUB,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(flag3 ? ASMItem::A3 : itemp2Reg[ir->items[2]->iVal])}));
    if (flag1)
      storeFromSP(asms, ASMItem::A1, spillOffsets[ir->items[0]->iVal]);
  } else if (ir->items[1]->type == IRItem::ITEMP &&
             ir->items[2]->type == IRItem::INT) {
    bool flag1 = itemp2Reg.find(ir->items[0]->iVal) == itemp2Reg.end(),
         flag2 = itemp2Reg.find(ir->items[1]->iVal) == itemp2Reg.end();
    if (flag2)
      loadFromSP(asms, ASMItem::A2, spillOffsets[ir->items[1]->iVal]);
    loadImmToReg(asms, ASMItem::A3, (unsigned)ir->items[2]->iVal);
    asms.push_back(new ASM(
        ASM::SUB,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag2 ? ASMItem::A2 : itemp2Reg[ir->items[1]->iVal]),
         new ASMItem(ASMItem::A3)}));
    if (flag1)
      storeFromSP(asms, ASMItem::A1, spillOffsets[ir->items[0]->iVal]);
  } else if (ir->items[1]->type == IRItem::INT &&
             ir->items[2]->type == IRItem::ITEMP) {
    bool flag1 = itemp2Reg.find(ir->items[0]->iVal) == itemp2Reg.end(),
         flag3 = itemp2Reg.find(ir->items[2]->iVal) == itemp2Reg.end();
    loadImmToReg(asms, ASMItem::A2, (unsigned)ir->items[1]->iVal);
    if (flag3)
      loadFromSP(asms, ASMItem::A3, spillOffsets[ir->items[2]->iVal]);
    asms.push_back(new ASM(
        ASM::SUB,
        {new ASMItem(flag1 ? ASMItem::A1 : itemp2Reg[ir->items[0]->iVal]),
         new ASMItem(ASMItem::A2),
         new ASMItem(flag3 ? ASMItem::A3 : itemp2Reg[ir->items[2]->iVal])}));
    if (flag1)
      storeFromSP(asms, ASMItem::A1, spillOffsets[ir->items[0]->iVal]);
  } else if (ir->items[1]->type == IRItem::FTEMP &&
             ir->items[2]->type == IRItem::FTEMP) {
    bool flag1 = ftemp2Reg.find(ir->items[0]->iVal) == ftemp2Reg.end(),
         flag2 = ftemp2Reg.find(ir->items[1]->iVal) == ftemp2Reg.end(),
         flag3 = ftemp2Reg.find(ir->items[2]->iVal) == ftemp2Reg.end();
    if (flag2)
      loadFromSP(asms, ASMItem::S1, spillOffsets[ir->items[1]->iVal]);
    if (flag3)
      loadFromSP(asms, ASMItem::S2, spillOffsets[ir->items[2]->iVal]);
    asms.push_back(new ASM(
        ASM::VSUB,
        {new ASMItem(flag1 ? ASMItem::S0 : ftemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag2 ? ASMItem::S1 : ftemp2Reg[ir->items[1]->iVal]),
         new ASMItem(flag3 ? ASMItem::S2 : ftemp2Reg[ir->items[2]->iVal])}));
    if (flag1)
      storeFromSP(asms, ASMItem::S0, spillOffsets[ir->items[0]->iVal]);
  } else if (ir->items[1]->type == IRItem::FTEMP &&
             ir->items[2]->type == IRItem::FLOAT) {
    bool flag1 = ftemp2Reg.find(ir->items[0]->iVal) == ftemp2Reg.end(),
         flag2 = ftemp2Reg.find(ir->items[1]->iVal) == ftemp2Reg.end();
    if (flag2)
      loadFromSP(asms, ASMItem::S1, spillOffsets[ir->items[1]->iVal]);
    loadImmToReg(asms, ASMItem::S2, ir->items[2]->fVal);
    asms.push_back(new ASM(
        ASM::VSUB,
        {new ASMItem(flag1 ? ASMItem::S0 : ftemp2Reg[ir->items[0]->iVal]),
         new ASMItem(flag2 ? ASMItem::S1 : ftemp2Reg[ir->items[1]->iVal]),
         new ASMItem(ASMItem::S2)}));
    if (flag1)
      storeFromSP(asms, ASMItem::S0, spillOffsets[ir->items[0]->iVal]);
  } else if (ir->items[1]->type == IRItem::FLOAT &&
             ir->items[2]->type == IRItem::FTEMP) {
    bool flag1 = ftemp2Reg.find(ir->items[0]->iVal) == ftemp2Reg.end(),
         flag3 = ftemp2Reg.find(ir->items[2]->iVal) == ftemp2Reg.end();
    loadImmToReg(asms, ASMItem::S1, ir->items[1]->fVal);
    if (flag3)
      loadFromSP(asms, ASMItem::S2, spillOffsets[ir->items[2]->iVal]);
    asms.push_back(new ASM(
        ASM::VSUB,
        {new ASMItem(flag1 ? ASMItem::S0 : ftemp2Reg[ir->items[0]->iVal]),
         new ASMItem(ASMItem::S1),
         new ASMItem(flag3 ? ASMItem::S2 : ftemp2Reg[ir->items[2]->iVal])}));
    if (flag1)
      storeFromSP(asms, ASMItem::S0, spillOffsets[ir->items[0]->iVal]);
  }
}

void ASMParser::popArgs(vector<ASM *> &asms) {
  ASM *tempASM = new ASM(ASM::VPOP, {});
  for (unsigned i = 0; i < usedRegNum[1]; i++)
    tempASM->items.push_back(new ASMItem(vFRegs[i]));
  if (tempASM->items.empty())
    delete tempASM;
  else
    asms.push_back(tempASM);
  tempASM = new ASM(ASM::POP, {});
  for (unsigned i = 0; i < usedRegNum[0]; i++)
    tempASM->items.push_back(new ASMItem(vIRegs[i]));
  tempASM->items.push_back(new ASMItem(ASMItem::PC));
  asms.push_back(tempASM);
}

void ASMParser::preProcess() {
  int id = 0;
  for (Symbol *symbol : consts)
    symbol->name = "var" + to_string(id++);
  for (Symbol *symbol : globalVars)
    symbol->name = "var" + to_string(id++);
  id = 0;
  for (pair<Symbol *, vector<IR *>> &funcIR : funcIRs) {
    if (funcIR.first->name.compare("main"))
      funcIR.first->name = "f" + to_string(id++);
    for (IR *ir : funcIR.second)
      if (ir->type == IR::LABEL)
        irLabels[ir] = labelId++;
  }
}

void ASMParser::saveArgRegs(vector<ASM *> &asms, Symbol *func) {
  unsigned iCnt = 0, fCnt = 0, offset = 0;
  for (unsigned i = 0; i < func->params.size(); i++) {
    if (!func->params[i]->dimensions.empty() ||
        func->params[i]->dataType == Symbol::INT) {
      if (iCnt < 4) {
        asms.push_back(new ASM(ASM::PUSH, {new ASMItem(aIRegs[iCnt++])}));
        offsets[func->params[i]] = -4 * (min(iCnt, 4u) + min(fCnt, 16u));
        savedRegs++;
      } else {
        offsets[func->params[i]] =
            offset + (usedRegNum[0] + usedRegNum[1] + 1) * 4;
        offset += 4;
      }
    } else {
      if (fCnt < 16) {
        asms.push_back(new ASM(ASM::VPUSH, {new ASMItem(aFRegs[fCnt++])}));
        offsets[func->params[i]] = -4 * (min(iCnt, 4u) + min(fCnt, 16u));
        savedRegs++;
      } else {
        offsets[func->params[i]] =
            offset + (usedRegNum[0] + usedRegNum[1] + 1) * 4;
        offset += 4;
      }
    }
  }
}

void ASMParser::saveUsedRegs(vector<ASM *> &asms) {
  ASM *tempASM = new ASM(ASM::PUSH, {});
  for (unsigned i = 0; i < usedRegNum[0]; i++)
    tempASM->items.push_back(new ASMItem(vIRegs[i]));
  tempASM->items.push_back(new ASMItem(ASMItem::LR));
  asms.push_back(tempASM);
  tempASM = new ASM(ASM::VPUSH, {});
  for (unsigned i = 0; i < usedRegNum[1]; i++)
    tempASM->items.push_back(new ASMItem(vFRegs[i]));
  if (tempASM->items.empty())
    delete tempASM;
  else
    asms.push_back(tempASM);
}

void ASMParser::storeFromSP(vector<ASM *> &asms, ASMItem::RegType source,
                            unsigned offset) {
  vector<unsigned> smartImm;
  for (unsigned mask : makeSmartImmMask(offset))
    smartImm.push_back(offset & mask);
  ASM::ASMOpType op = isFloatReg(source) ? ASM::VSTR : ASM::STR;
  unsigned maxOffset = isFloatReg(source) ? 1020 : 4095;
  switch (smartImm.size()) {
  case 0:
    asms.push_back(
        new ASM(op, {new ASMItem(source), new ASMItem(ASMItem::SP)}));
    break;
  case 1:
    if (offset <= maxOffset)
      asms.push_back(new ASM(op, {new ASMItem(source), new ASMItem(ASMItem::SP),
                                  new ASMItem(offset)}));
    else {
      asms.push_back(
          new ASM(ASM::ADD, {new ASMItem(ASMItem::A4), new ASMItem(ASMItem::SP),
                             new ASMItem(offset)}));
      asms.push_back(
          new ASM(op, {new ASMItem(source), new ASMItem(ASMItem::A4)}));
    }
    break;
  case 2:
    if (offset <= maxOffset) {
      asms.push_back(new ASM(op, {new ASMItem(source), new ASMItem(ASMItem::SP),
                                  new ASMItem(offset)}));
    } else if (!(offset & 0xffff0000)) {
      asms.push_back(
          new ASM(ASM::MOV, {new ASMItem(ASMItem::A4), new ASMItem(offset)}));
      asms.push_back(new ASM(op, {new ASMItem(source), new ASMItem(ASMItem::SP),
                                  new ASMItem(ASMItem::A4)}));
    } else if (smartImm[1] <= maxOffset) {
      asms.push_back(
          new ASM(ASM::ADD, {new ASMItem(ASMItem::A4), new ASMItem(ASMItem::SP),
                             new ASMItem(smartImm[0])}));
      asms.push_back(new ASM(op, {new ASMItem(source), new ASMItem(ASMItem::A4),
                                  new ASMItem(smartImm[1])}));
    } else {
      asms.push_back(new ASM(
          ASM::MOV, {new ASMItem(ASMItem::A4), new ASMItem(offset & 0xffff)}));
      asms.push_back(new ASM(
          ASM::MOVT, {new ASMItem(ASMItem::A4), new ASMItem(offset >> 16)}));
      asms.push_back(
          new ASM(ASM::ADD, {new ASMItem(ASMItem::A4), new ASMItem(ASMItem::SP),
                             new ASMItem(ASMItem::A4)}));
      asms.push_back(new ASM(op, {new ASMItem(source), new ASMItem(ASMItem::SP),
                                  new ASMItem(ASMItem::A4)}));
    }
    break;
  default:
    asms.push_back(new ASM(
        ASM::MOV, {new ASMItem(ASMItem::A4), new ASMItem(offset & 0xffff)}));
    asms.push_back(new ASM(
        ASM::MOVT, {new ASMItem(ASMItem::A4), new ASMItem(offset >> 16)}));
    asms.push_back(
        new ASM(ASM::ADD, {new ASMItem(ASMItem::A4), new ASMItem(ASMItem::SP),
                           new ASMItem(ASMItem::A4)}));
    asms.push_back(new ASM(op, {new ASMItem(source), new ASMItem(ASMItem::SP),
                                new ASMItem(ASMItem::A4)}));
    break;
  }
}

void ASMParser::switchLCmpLogic(IR *ir) {
  switch (ir->type) {
  case IR::BEQ:
    ir->type = IR::BNE;
    break;
  case IR::BGE:
    ir->type = IR::BLT;
    break;
  case IR::BGT:
    ir->type = IR::BLE;
    break;
  case IR::BLE:
    ir->type = IR::BGT;
    break;
  case IR::BLT:
    ir->type = IR::BGE;
    break;
  case IR::BNE:
    ir->type = IR::BEQ;
    break;
  case IR::EQ:
    ir->type = IR::NE;
    break;
  case IR::GE:
    ir->type = IR::LT;
    break;
  case IR::GT:
    ir->type = IR::LE;
    break;
  case IR::LE:
    ir->type = IR::GT;
    break;
  case IR::LT:
    ir->type = IR::GE;
    break;
  case IR::NE:
    ir->type = IR::EQ;
    break;
  default:
    break;
  }
  swap(ir->items[1], ir->items[2]);
}
